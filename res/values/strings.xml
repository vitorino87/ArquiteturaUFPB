<resources><string name="app_name">Arquitetura UFPB</string>
    <string name="q1">Todo computador possui uma Unidade Central de Processamento, ou, do inglês, Central Processing Unit (CPU) e uma ___________. Todos os dados a serem processados pela CPU, para operações ___________, precisam estar na ___________.</string>
    <string name="q1a">A)Memória Principal; controle; memória</string>
    <string name="q1b">B)Memória Principal; controle; CPU</string>
    <string name="q1c">C)Memória Principal; lógicas e aritméticas; memória</string>
    <string name="q1d">D)Memória Secundária; lógicas e aritméticas; CPU</string>
    <string name="q1e">E)Memória Secundária; controle; memória</string>
    <string name="q2">Da memória os dados são transferidos para a ___________ através de ﬁos ___________ de comunicação, chamados de ___________.</string>
    <string name="q2a">A)CPU; paralelos; Barramento de Dados</string>
    <string name="q2b">B)memória cache; seriais; Barramento de Dados</string>
    <string name="q2c">C)CPU; seriais; Barramento de Dados</string>
    <string name="q2d">D)memória cache; paralelos; Barramento de Endereço</string>
    <string name="q2e">E)CPU; seriais; Barramento de Endereço</string>
    <string name="q3">A CPU não toma decisões por si própria. Ela não sabe que dados deve trazer da memória, muito menos que operação executar com eles. Ela precisa que ___________, também armazenadas na ___________, sejam trazidas para a CPU através do ___________. Cada instrução informa para a CPU que operação ela deve executar, com quais dados e o que ela deve fazer com ___________.</string>
    <string name="q3a">A)instruções; memória; Barramento de Dados; o resultado da informação</string>
    <string name="q3b">B)as informações; memória; Barramento de Endereço; o resultado da operação</string>
    <string name="q3c">C)as informações; CPU; Barramento de Dados; o resultado da informação</string>
    <string name="q3d">D)instruções; memória; Barramento de Endereço; o resultado da operação</string>
    <string name="q3e">E)instruções; CPU; Barramento de Endereço; o resultado da operação</string>
    <string name="q4">Para poder se localizar, a memória é organizada em ___________. Todos os dados e as instruções são localizadas através desses ___________. Cada instrução indica para a CPU que dados devem ser ___________ através dos ___________ desses dados.</string>
    <string name="q4a">A)endereços; regiões; transferidos e processados; regiões</string>
    <string name="q4b">B)regiões; regiões; transferidos e processados; endereços</string>
    <string name="q4c">C)endereços; endereços; processados; endereços</string>
    <string name="q4d">D)regiões; endereços; processados; endereços</string>
    <string name="q4e">E)endereços; endereços; transferidos e processados; endereços</string>
    <string name="q5">O endereço é transferido para a memória pela CPU através do:</string>
    <string name="q5a">A)Barramento de Dados</string>
    <string name="q5b">B)Barramento de Endereço</string>
    <string name="q5c">C)Barramento de Controle</string>
    <string name="q5d">D)Barramento de Processamento</string>
    <string name="q5e">E)Barramento de Instrução</string>
    <string name="q6">A memória localiza o dado e o transfere para a CPU via:</string>
    <string name="q6a">A)Barramento de Dados</string>
    <string name="q6b">B)Barramento de Endereço</string>
    <string name="q6c">C)Barramento de Controle</string>
    <string name="q6d">D)Barramento de Processamento</string>
    <string name="q6e">E)Barramento de Instrução </string>
    <string name="q7">As instruções são desenvolvidas pelo programador, através de linguagens de programação. As ferramentas de compilação transformam os programas escritos em linguagens de alto nível, como C, Java e Phython, em ___________, que são ﬁnalmente copiadas para a memória no momento em que precisam ser executadas. Cada instrução é armazenada em um ___________ da memória. Na execução normal, a CPU passa para a memória, via ___________, o endereço da ___________ instrução do programa, a memória transfere a instrução pelo ___________, a CPU a executa e, em seguida, solicita a instrução do endereço seguinte.</string>
    <string name="q7a">A)instruções de máquina; mesmo endereço; Barramento de Endereço; segunda; Barramento de Instrução</string>
    <string name="q7b">B)instruções Assembly; endereço diferente; Barramento de Dados; primeira; Barramento de Endereço</string>
    <string name="q7c">C)instruções de máquina; endereço diferente; Barramento de Endereço; primeira; Barramento de Instrução</string>
    <string name="q7d">D)instruções Assembly; mesmo endereço; Barramento de Endereço; segunda; Barramento de Dados</string>
    <string name="q7e">E)instruções de máquina; endereço diferente; Barramento de Dados; primeira; Barramento de Instrução</string>
    <string name="q8">Os programas são executados sempre de forma ___________, a não ser que uma instrução especial solicite que ela salte para uma instrução que não seja a ___________. Isso é o caso quando há instruções ___________ (como o “se” ou if), instruções ___________ (como while e o for), ou chamadas a sub-programas, ou mesmo, por ordem do Sistema Operacional, para que o programa pare de executar para que um outro tome seu lugar.</string>
    <string name="q8a">A)sequencial; consecutiva; de repetição; condicionais</string>
    <string name="q8b">B)sequencial; paralela; condicionais; de repetição</string>
    <string name="q8c">C)paralela; consecutiva; condicionais; de repetição</string>
    <string name="q8d">D)paralela; paralela; condicionais; de repetição</string>
    <string name="q8e">E)sequencial; consecutiva; condicionais; de repetição</string>
    <string name="q9">As memórias são, quase sempre, muito mais lentas do que as CPUs. Isso exigiu, ao longo dos anos, que as CPUs possuíssem também uma porção interna de memória muito rápida, chamada ___________. A tecnologia que permite essas memórias serem mais rápidas, tornam-as também muito caras. Por isso que sua capacidade geralmente é muito limitada. Para acelerar ainda mais, elas são instaladas ___________ das CPUs. Todos os dados e instruções transferidos da Memória Principal para a CPU são salvos também na Cache. Como a Cache não é capaz de guardar todos os dados da Memória Principal, apenas os dados mais ___________ transferidos para a CPU permanecem na Cache.</string>
    <string name="q9a">A)Memória Cache; dentro; recentes</string>
    <string name="q9b">B)Memória Principal; dentro; antigos</string>
    <string name="q9c">C)Memória Cache; fora; recentes</string>
    <string name="q9d">D)Memória Principal; dentro; recentes</string>
    <string name="q9e">E)Memória Primária; fora; antigos</string>
    <string name="q10">A CPU também é responsável por enviar sinais de controle aos outros dispositivos do computador, como periféricos, dispositivos de entrada e saída, e memórias externas. Por exemplo, quando uma instrução pede que uma mensagem seja impressa na tela, a CPU, ao ___________ essa instrução, envia para o controle do monitor que imprima na tela a mensagem contida ___________ que também foi passada ___________.</string>
    <string name="q10a">A)receber e executar; na instrução; pelo endereço</string>
    <string name="q10b">B)receber e executar; no endereço; pelo endereço</string>
    <string name="q10c">C)receber e executar; no endereço; pela instrução</string>
    <string name="q10d">D)receber; no endereço; pela instrução</string>
    <string name="q10e">E)executar; no endereço; pela instrução</string>
    <string name="q11">Todos computadores executam três operações básicas: \n1. Movimentação de dados\n2. Processamentos de dados\n3. Armazenamento de dados</string>
    <string name="q11a">A)1</string>
    <string name="q11b">B)1 e 2</string>
    <string name="q11c">C)1 e 3</string>
    <string name="q11d">D)2 e 3</string>
    <string name="q11e">E)1, 2 e 3</string>
    <string name="q12">___________ é a transferência de um dado de um ponto para outro do computador. Pode ser de um endereço de memória para outro, de um dispositivo de entrada para a memória, ou da memória para um dispositivo de saída.</string>
    <string name="q12a">A)Armazenamento de dados</string>
    <string name="q12b">B)Movimentação de dados</string>
    <string name="q12c">C)Processamento de dados</string>
    <string name="q12d">D)Mapeamento associativo por conjunto</string>
    <string name="q12e">E)Microoperações</string>
    <string name="q13">___________ ocorre quando a CPU recebe um determinado dado e executa uma operação que o modiﬁca de alguma forma.</string>
    <string name="q13a">A)Armazenamento de dados</string>
    <string name="q13b">B)Movimentação de dados</string>
    <string name="q13c">C)Processamento de dados</string>
    <string name="q13d">D)Mapeamento associativo por conjunto</string>
    <string name="q13e">E)Microoperações</string>
    <string name="q14">___________ ocorre quando a CPU precisa registrar um dado em algum local especíﬁco, como salvar um dado no disco rígido, ou num pendrive, ou mesmo na Memória Principal.</string>
    <string name="q14a">A)Armazenamento de dados</string>
    <string name="q14b">B)Movimentação de dados</string>
    <string name="q14c">C)Processamento de dados</string>
    <string name="q14d">D)Mapeamento associativo por conjunto</string>
    <string name="q14e">E)Microoperações</string>
    <string name="q15">Von Neumann recomendou em sua arquitetura que os dados e instruções fossem agora armazenados em binário, facilitando a análise dos mesmos e reduzindo a quantidade de erros. Em 1952, o professor John von Neumann, da Univeridade de Princeton, Estados Unidos, apresentou um projeto inusitado para a arquitetura de um computador. Ele sugeriu que o computador fosse organizado em componentes, cada um executando apenas uma única tarefa e de forma muito mais organizada. Ele propôs que o computador fosse composto por:\n1. Memória Principal\n2. Unidade Lógica e Aritmética (ULA)\n3. Unidade de Controle\n4. Unidade Central de Processamento (CPU)\n5. Unidade de Entrada e Saída\ni. que agruparia a ULA e a Unidade de Controle \nii. responsável por armazenar os programas a serem executados, assim como os dados a serem processados \niii. para realização das operações lógicas e aritméticas \niv. responsável pela comunicação com os periféricos do computador (teclado, monitor, memória externa etc.)\nv. que, baseado nas instruções lidas da memória, enviaria sinais de controle para a ULA para que a mesma executasse as operações devidas </string>
    <string name="q15a">A)1-i; 2-ii; 3-v; 4-iii; 5-iv </string>
    <string name="q15b">B)1-i; 2-iii; 3-iv; 4-ii; 5-v</string>
    <string name="q15c">C)1-ii; 2-iii; 3-v; 4-i; 5-iv</string>
    <string name="q15d">D)1-ii; 2-iv; 3-i; 4-v; 5-iii</string>
    <string name="q15e">E)1-iii; 2-i; 3-v; 4-ii; 5-iv</string>
    <string name="q16">Os programas são sequências ___________ de passos que foram deﬁnidas por um programador para alcançar um objetivo especíﬁco. Cada passo desse programa é chamado de ___________. Geralmente, uma instrução de uma linguagem de alto nível embute vários comandos e ações a serem executadas pela CPU. Após compilado, o programa de linguagem de alto nível é transformado em um programa apenas com instruções de máquina. Cada instrução de máquina contém ___________ a ser realizada pela CPU.</string>
    <string name="q16a">A)inﬁnitas; instrução; várias operações</string>
    <string name="q16b">B)inﬁnitas; processamento; apenas uma única operação</string>
    <string name="q16c">C)ﬁnitas; instrução; várias operações</string>
    <string name="q16d">D)ﬁnitas; processamento; várias operações</string>
    <string name="q16e">E)ﬁnitas; instrução; apenas uma única operação</string>
    <string name="q17">No princípio, um ___________, copiava todas as instruções para a memória de maneira quase que manual. Hoje em dia essa operação é realizada pelo ___________ . Assim que um usuário clica com o mouse, ou pressiona a tecla ___________ do teclado solicitando que um determinado programa execute, o Sistema Operacional copia o programa para a memória e solicita que a CPU o execute.</string>
    <string name="q17a">A)Sistema Operacional (Windows, Linux etc.); Operador de Máquina; Enter</string>
    <string name="q17b">B)Operador de Máquina; Sistema Operacional (Windows, Linux etc.); Enter</string>
    <string name="q17c">C)Operador de Máquina; Sistema Operacional (Windows, Linux etc.); BackSpace</string>
    <string name="q17d">D)Sistema Operacional (Windows, Linux etc.); Operador de Máquina; BackSpace</string>
    <string name="q17e">E)Operador de Máquina (Windows, Linux etc.); Sistema Operacional; Enter</string>
    <string name="q18">Podemos dizer que um programa em linguagem de máquina é formado por instruções em ___________. A cada instrução trazida da memória, a CPU lê seu código ___________ de operação para saber do que se trata, e inicia o processo de execução. Dependendo da operação, que pode ser de movimentação de dados, uma operação lógica, ou aritmética, ou uma operação de armazenamento de dados, a CPU envia ordens para que os outros dispositivos do computador atuem de forma a completar a operação. Essas ordens são enviadas através de ___________ passados por ﬁos dentro do computador. Esses ﬁos são chamados de ___________.</string>
    <string name="q18a">A)binário; binário; pulsos magnéticos; Barramento de Instrução</string>
    <string name="q18b">B)octal; octal; pulsos elétricos; Barramento de Controle</string>
    <string name="q18c">C)binário; binário; pulsos magnéticos; Barramento de Dados</string>
    <string name="q18d">D)binário; binário; pulsos elétricos; Barramento de Controle</string>
    <string name="q18e">E)hexadecimal; octal; pulsos elétricos; Barramento de Endereço</string>
    <string name="q19">Soluções em software são sempre mais ___________ do que soluções equivalentes em hardware. Isso porque para executar um programa, cada instrução deve antes ser armazenada em memória, transferidas para a CPU (lembre-se que memórias são muito mais ___________ do que CPUs) e, só então, ser executada pela CPU. Já as soluções em hardware não utilizam instruções, elas executam as operações diretamente. Por outro lado, as soluções em software ___________ em ﬂexibilidade, já que os programas podem ser facilmente modiﬁcados. Já as soluções em hardware, não. Uma vez concebido, um hardware não pode mais ser modiﬁcado, ele deve ser descartado para dar lugar a uma versão mais nova.</string>
    <string name="q19a">A)lentas; lentas; perdem</string>
    <string name="q19b">B)velozes; lentas; ganham</string>
    <string name="q19c">C)lentas; lentas; ganham</string>
    <string name="q19d">D)lentas; velozes; perdem</string>
    <string name="q19e">E)velozes; velozes; perdem</string>
    <string name="q20">Toda CPU é formada por duas unidades, como podem ser vistas na Figura 2.</string>
    <string name="q20a">A)Unidade de Controle (UC) e Unidade de Ciclo de Dados (UCD)</string>
    <string name="q20b">B)Unidade de Processamento (UP) e Unidade de Ciclo de Dados (UCD) </string>
    <string name="q20c">C)Unidade de Controle (UC) e Unidade de Ciclo de Processamento (UCP) </string>
    <string name="q20d">D)Unidade de Processamento (UP) e Unidade de Ciclo de Dados (UCD) </string>
    <string name="q20e">E)Unidade de Controle (UC) e Unidade de Ciclo de Processamento (UCD) </string>
    <string name="q21">A ___________ é responsável por receber instruções pelo ___________. As instruções vêm da memória de acordo com o endereço enviado pela UC para a memória através do ___________ das instruções</string>
    <string name="q21a">A)Unidade de Controle; Barramento de Dados; Barramento de Endereço</string>
    <string name="q21b">B)Unidade de Controle; Barramento de Endereço; Barramento de Controle</string>
    <string name="q21c">C)Unidade de Ciclo de Processamento; Barramento de Instruções; Barramento de Endereço</string>
    <string name="q21d">D)Unidade de Ciclo de Processamento; Barramento de Controle; Barramento de Endereço</string>
    <string name="q21e">E)Unidade de Controle; Barramento de Instruções; Barramento de Endereço</string>
    <string name="q22">___________, como o próprio nome deixa entender, é responsável por tratar os dados propriamente ditos. A ___________ não executa as instruções. Ela as lê, decodiﬁca e passa os comandos para a UCD determinando como as instruções devem ser executadas e com quais dados. Baseada nesses comandos, a UCD pode ir buscar os dados necessários na memória, executar as devidas operações e enviar o resultado de volta para a memória para ser armazenado. Tudo controlado de acordo com os comandos internos enviados pela ___________, que por sua vez se baseia na instrução decodiﬁcada.</string>
    <string name="q22a">A)Unidade de Ciclo de Dados; Unidade de Controle; Unidade de Controle</string>
    <string name="q22b">B)Unidade de Controle; Unidade de Ciclo de Dados; Unidade de Controle</string>
    <string name="q22c">C)Unidade de Ciclo de Dados; Unidade de Ciclo de Dados; Unidade de Ciclo de Dados</string>
    <string name="q22d">D)Unidade de Controle; Unidade de Controle; Unidade de Ciclo de Dados</string>
    <string name="q22e">E)Unidade de Controle; Unidade de Controle; Unidade de Controle</string>
    <string name="q23">Os dados lidos, ou enviados para a memória, são transmitidos através do ___________. Os endereços são enviados para a memória através do ___________. Tudo isso é controlado por um sinal ___________ de relógio (clock, do inglês). A cada batida do relógio a unidade sabe que deve executar um passo, passar os dados para quem deve, e se preparar para o próximo passo. Quanto mais rápido é o relógio mais operações por segundo o processador consegue executar e mais rápido pode se tornar. A velocidade do relógio é medida em frequência, utilizando a unidade Hertz (abreviatura é Hz). Um Hertz signiﬁca um passo por segundo.</string>
    <string name="q23a">A)Barramento de Endereço; Barramento de Endereço; assíncrono</string>
    <string name="q23b">B)Barramento de Dados; Barramento de Endereço; assíncrono</string>
    <string name="q23c">C)Barramento de Dados; Barramento de Endereço; síncrono</string>
    <string name="q23d">D)Barramento de Controle; Barramento de Instrução; síncrono</string>
    <string name="q23e">E)Barramento de Controle; Barramento de Endereço; síncrono</string>
    <string name="q24">A comunicação da ___________ e da ___________ é feita sempre com ___________ através dos barramentos.</string>
    <string name="q24a">A)Unidade de Controle; Unidade de Ciclo de Dados; o Registrador de Instruções</string>
    <string name="q24b">B)Unidade de Ciclo de Dados; Unidade de Controle; a Memória Principal</string>
    <string name="q24c">C)Unidade de Controle; Unidade de Ciclo de Dados; o Contador de Programas (PC)</string>
    <string name="q24d">D)Unidade de Ciclo de Dados; Unidade de Controle; a Memória Cache</string>
    <string name="q24e">E)Unidade de Controle; Unidade de Ciclo de Dados; o Registrador</string>
    <string name="q25">Os endereços são transmitidos sempre via ___________ para a memória, sempre de forma ___________ da CPU para a memória.</string>
    <string name="q25a">A)Barramento de Endereços; unidirecional</string>
    <string name="q25b">B)Barramento de Dados; unidirecional</string>
    <string name="q25c">C)Barramento de Controle; unidirecional</string>
    <string name="q25d">D)Barramento de Endereços; bidirecional</string>
    <string name="q25e">E)Barramento de Dados; bidirecional</string>
    <string name="q26">Quando as instruções são transmitidas da memória para a ___________, elas utilizam o ___________. Isso porque as instruções são tratadas pela memória como um conteúdo como um outro qualquer. Ela ___________ distinção entre dados e instruções.</string>
    <string name="q26a">A)Unidade de Controle; Barramento de Instruções; faz</string>
    <string name="q26b">B)Unidade de Ciclo de Dados; Barramento de Dados; faz</string>
    <string name="q26c">C)Unidade de Controle; Barramento de Instruções; não faz</string>
    <string name="q26d">D)Unidade de Ciclo e Dados; Barramento de Instrução; não faz</string>
    <string name="q26e">E)Unidade de Controle; Barramento de Dados; não faz</string>
    <string name="q27">O ___________ é utilizado pela ___________ para receber os operandos das operações a serem realizadas e para enviar os resultados de volta para a ___________.</string>
    <string name="q27a">A)Barramento de Instruções; Unidade de Ciclo de Dados; memória Cache</string>
    <string name="q27b">B)Barramento de Endereço; Unidade de Controle; memória</string>
    <string name="q27c">C)Barramento de Endereço; Unidade de Ciclo de Dados; memória Cache</string>
    <string name="q27d">D)Barramento de Dados; Unidade de Ciclo de Dados; memória</string>
    <string name="q27e">E)Barramento de Dados; Unidade de Controle; memória</string>
    <string name="q28">Quando você deseja executar um programa de um pendrive conectado pela USB do computador, ele antes ___________ ser copiado para a ___________. ___________ ele será ___________.</string>
    <string name="q28a">A)precisa; Memória Cache; Então; executado</string>
    <string name="q28b">B)precisa; Memória Principal; Só então; executado</string>
    <string name="q28c">C)precisa; Memória Principal; Só então; interrompido</string>
    <string name="q28d">D)não precisa; Memória Cache; Então; interrompido</string>
    <string name="q28e">E)não precisa; Memória Principal; Só então; executado</string>
    <string name="q29">A memória precisa ser ___________ o bastante para armazenar ___________ quantidade possível de programas, e também precisa ser rápida o suﬁciente para buscar os dados e enviá-los o mais rapidamente possível à CPU, e também salvá-los no ___________ tempo possível. A velocidade das memórias é determinada essencialmente pela tecnologia de transistores utilizada.</string>
    <string name="q29a">A)grande; a maior; menor</string>
    <string name="q29b">B)pequena; a menor; maior</string>
    <string name="q29c">C)grande; a maior; menor</string>
    <string name="q29d">D)grande; a menor; maior</string>
    <string name="q29e">E)pequena; a maior; menor</string>
    <string name="q30">___________ são memórias elaboradas com o ___________ de transistores possível, utilizando o que há de mais moderno em tecnologia de armazenamento. Elas são as memórias ___________ rápidas que podem ser construídas e por isso são também as mais caras. Por essa razão, elas aparecem numa quantidade muito pequena em um computador, na casa de alguns Kilo Bytes.</string>
    <string name="q30a">A)Registradores; máximo; menos</string>
    <string name="q30b">B)Memórias Cache; mínimo; menos</string>
    <string name="q30c">C)Registradores; mínimo; mais</string>
    <string name="q30d">D)Memórias Cache; máximo; mais</string>
    <string name="q30e">E)Registradores; máximo; mais</string>
    <string name="q31">Os registradores podem ser divididos em dois grupos: </string>
    <string name="q31a">A)Os registradores de propósito geral, e os de propósito especíﬁco</string>
    <string name="q31b">B)Os registradores de informações, e os de propósito geral</string>
    <string name="q31c">C)Os registradores de informações, e os de propósito especíﬁco</string>
    <string name="q31d">D)Os registradores de propósito geral, e os de propósito geral</string>
    <string name="q31e">E)Os registradores sem propósito geral, e os de propósito especíﬁco</string>
    <string name="q32">Os ___________ podem ser utilizados pelos programas para quaisquer objetivos, os de ___________ são especíﬁcos para algumas tarefas. Por exemplo, há um registrador na CPU para controlar se o processador deve continuar em execução, ou entrar em modo de espera por nova ordem. Se esse registrador receber um valor diferente de zero, o processador entrará em ___________, até que receba a ordem de modiﬁcar esse valor.</string>
    <string name="q32a">A)propósito especíﬁco; registradores de propósito geral; modo de parada</string>
    <string name="q32b">B)registradores de propósito geral; propósito especíﬁco; modo de execução</string>
    <string name="q32c">C)propósito especíﬁco; registradores de propósito geral; modo de execução</string>
    <string name="q32d">D)registradores de propósito geral; propósito especíﬁco; modo de espera</string>
    <string name="q32e">E)propósito especíﬁco; registradores de propósito geral; modo de espera</string>
    <string name="q33">Os registradores de propósito especíﬁco são: </string>
    <string name="q33a">A)Program Counter (PC): Contador de Programas; Instruction Register (IR): Registrador de Instrução; Static Random Access Memory(SRAM): Memória estática de acesso aleatório; Memory Buffer Register (MBR): Registrador de Dados </string>
    <string name="q33b">B)Program Counter (PC): Contador de Programas; Synchronous dynamic random access memory (SDRAM): memória de acesso dinâmico randômico; Memory Address Register (MAR): Registrador de Endereço; Double data rate SDRAM: dobro da taxa de dados SDRAM </string>
    <string name="q33c">C)Synchronous dynamic random access memory (SDRAM): memória de acesso dinâmico randômico;; Instruction Register (IR): Registrador de Instrução; Memory Address Register (MAR): Registrador de Endereço; Double data rate SDRAM: dobro da taxa de dados SDRAM </string>
    <string name="q33d">D)Synchronous dynamic random access memory (SDRAM): memória de acesso dinâmico randômico;; Instruction Register (IR): Registrador de Instrução; Memory Address Register (MAR): Registrador de Endereço; Memory Buffer Register (MBR): Registrador de Dados</string>
    <string name="q33e">E)Program Counter (PC): Contador de Programas; Instruction Register (IR): Registrador de Instrução; Memory Address Register (MAR): Registrador de Endereço; Memory Buffer Register (MBR): Registrador de Dados</string>
    <string name="q34">O PC contém o endereço de memória que será utilizado para buscar a próxima instrução a ser executada pela CPU. Antes de executar qualquer instrução, a CPU envia o conteúdo de PC para a memória através do ___________, a memória envia o conteúdo da memória nesse endereço através do ___________. Esse conteúdo é então armazenado no IR. Já o IR, que recebeu a instrução que veio da memória, tem o objetivo de guardar a instrução e passá-la para a ___________, que é quem vai lê-la e tomar as decisões necessárias para que ela seja executada pela ___________.</string>
    <string name="q34a">A)Barramento de Dados; Barramento de Endereço; Unidade de Ciclo de Dados; Unidade de Controle</string>
    <string name="q34b">B)Barramento de Endereço; Barramento de Dados; Unidade de Controle; Unidade de Ciclo de Dados</string>
    <string name="q34c">C)Barramento de Endereço; Barramento de Instruções; Unidade de Ciclo de Dados; Unidade de Controle</string>
    <string name="q34d">D)Barramento de Instruções; Barramento de Dados; Unidade de Controle; Unidade de Ciclo de Dados</string>
    <string name="q34e">E)Barramento de Instruções; Barramento de Endereço; Unidade de Controle; Unidade de Ciclo de Dados</string>
    <string name="q35">Por se tratarem do processo de busca de instruções, o ___________ e o ___________ ﬁcam instalados na ___________.</string>
    <string name="q35a">A)PC; MAR; Unidade de Controle</string>
    <string name="q35b">B)PC; IR; Unidade de Ciclo de Dados</string>
    <string name="q35c">C)PC; MBR; Unidade de Controle</string>
    <string name="q35d">D)PC; IR; Unidade de Controle</string>
    <string name="q35e">E)PC; SRAM; Unidade de Ciclo de Dados</string>
    <string name="q36">O ___________ possui conexão direta com o ___________, e o ___________ com o ___________.</string>
    <string name="q36a">A)IR; Barramento de Endereços; PC; Barramento de Instruções</string>
    <string name="q36b">B)PC; Barramento de Endereços; IR; Barramento de Instruções</string>
    <string name="q36c">C)IR; Barramento de Dados; MAR; Barramento de Endereços</string>
    <string name="q36d">D)IR; Barramento de Dados; MBR; Barramento de Endereços</string>
    <string name="q36e">E)MAR; Barramento de Endereços; PC; Barramento de Instruções</string>
    <string name="q37">Com relação ao ___________ e ao ___________, eles possuem funções análogas ao PC e IR, respectivamente, mas referentes a dados e não a instruções. Quando uma operação precisa ser realizada com algum dado que está na memória (e não em um registrador), o endereço desse dado é passado para o MAR. A CPU então passa o conteúdo de MAR para a memória através do ___________, que retornará o conteúdo da memória nesse endereço através do ___________. O conteúdo trazido pela memória será armazenado em MBR. Só então o dado poderá ser utilizado para o processamento inicialmente planejado.</string>
    <string name="q37a">A)MAR; MBR; Barramento de Endereço; Barramento de Dados</string>
    <string name="q37b">B)MBR; MAR; Barramento de Dados; Barramento de Endereço</string>
    <string name="q37c">C)MAR; MBR; Barramento de Endereço; Barramento de Instruções</string>
    <string name="q37d">D)MBR; MAR; Barramento de Instruções; Barramento de Dados</string>
    <string name="q37e">E)MAR; MBR; Barramento de Endereço; Barramento de Instruções</string>
    <string name="q38">O ___________ e ___________ possuem, respectivamente, conexões diretas com os ___________. Ambos são situados na ___________, por serem utilizados nas fases de processamento das instruções.</string>
    <string name="q38a">A)MAR; MBR; Barramentos de Dados e de Endereços; Unidade de Ciclo de Dados</string>
    <string name="q38b">B)MBR; MAR; Barramentos de Dados e de Endereços; Unidade de Ciclo de Dados</string>
    <string name="q38c">C)MAR; MBR; Barramentos de Endereço e de Dados; Unidade de Controle</string>
    <string name="q38d">D)MBR; MAR; Barramentos de Dados e de Endereços; Unidade de Controle</string>
    <string name="q38e">E)MAR; MBR; Barramentos de Dados e de Instruções; Unidade de Ciclo de Dados</string>
    <string name="q39">O tamanho e quantidade dos registradores de uma CPU é uma das principais decisões de projeto. Se forem grandes demais, ou em quantidade maior do que a necessária, podem resultar em desperdício e ___________ no preço do processador. Já se forem pequenos, ou em pouca quantidade, com certeza vão tornar o computador ___________ do que o desejado.</string>
    <string name="q39a">A)aumento desnecessário; muito mais lento</string>
    <string name="q39b">B)redução necessário; muito mais rápido</string>
    <string name="q39c">C)redução desnecessária; muito mais lento</string>
    <string name="q39d">D)aumento necessário; muito mais rápido</string>
    <string name="q39e">E)aumento necessário; muito mais lento</string>
    <string name="q40">Os ___________ são utilizados para guardar as variáveis dos programas. Como eles estão presentes em quantidades muito pequenas, são poucas as variáveis que ﬁcam armazenadas em registradores. As demais ﬁcam na ___________. Quando uma operação precisa ser realizada e seus dados estão nos ___________, a CPU não precisa buscá-los na memória e o processamento torna-se muito mais rápido.</string>
    <string name="q40a">A)registradores de propósito geral; Memória Principal; Registradores de Propósito Específico;</string>
    <string name="q40b">B)registradores de propósito geral; Memória Cache; Registradores de Propósito Específico;</string>
    <string name="q40c">C)registradores de propósito específico; Memória Cache; Registradores de Propósito Geral</string>
    <string name="q40d">D)registradores de propósito específico; Memória Principal; Registradores de Propósito Geral</string>
    <string name="q40e">E)registradores de propósito geral; Memória Principal; Registradores de Propósito Geral</string>
    <string name="q41">A CPU tenta ao ___________ manter as variáveis ___________ utilizadas nos registradores. Ela faz isso guardando aquelas mais usadas nas últimas operações. Faça suas variáveis mais importantes serem ___________ utilizadas. Usando-as em ___________, por exemplo. Isso aumentará as chances delas serem armazenadas em registradores, podendo acelerar a execução dos seus programas.</string>
    <string name="q41a">A)máximo; mais; pouco; constantes</string>
    <string name="q41b">B)mínimo; menos; pouco; repetições</string>
    <string name="q41c">C)mínimo; menos; pouco; constantes</string>
    <string name="q41d">D)máximo; mais; bastante; repetições</string>
    <string name="q41e">E)máximo; mais; bastante; repetições</string>
    <string name="q42">A ___________, ou ULA, se assemelha muito com uma calculadora convencional. Ela executa ___________. As ULAs modernas executam operações tanto com ___________, como com números reais.</string>
    <string name="q42a">A)Unidade Lógica e Aritmética; operações lógicas e aritméticas; Strings</string>
    <string name="q42b">B)Unidade Lógica e Aritmética; operações lógicas e arbitrárias; Strings</string>
    <string name="q42c">C)Unidade Lógica e Aritmética; operações lógicas e aritméticas; inteiros</string>
    <string name="q42d">D)Unidade Lógica e Algoritmo; operações lógicas e aritméticas; inteiros</string>
    <string name="q42e">E)Unidade Lógica e Algoritmo; operações lógicas e aritméticas; inteiros</string>
    <string name="q43">A ULA recebe como entrada dois diferentes dados que são trazidos para ela dos ___________. Quem decide que registradores passarão seus dados para a ULA é a ___________ baseada no tipo da instrução que está sendo executada.</string>
    <string name="q43a">A)registradores (apenas de propósito geral); Unidade de Controle</string>
    <string name="q43b">B)registradores (apenas de propósito especíﬁcos); Unidade de Controle</string>
    <string name="q43c">C)registradores (apenas de propósito geral); Unidade de Ciclo de Dados</string>
    <string name="q43d">D)registradores (de propósito geral, ou especíﬁcos); Unidade de Ciclo de Dados</string>
    <string name="q43e">E)registradores (de propósito geral, ou especíﬁcos); Unidade de Controle</string>
    <string name="q44">A ___________ também envia para a ULA qual operação será realizada (soma, multiplicação, divisão, AND, OR etc.). Assim que isso é feito, a ULA executa a operação e gera um resultado na sua saída. Esse resultado também é passado para ___________ escolhido pela ___________, baseando-se na instrução em execução.</string>
    <string name="q44a">A)Unidade de Ciclo de Dados; um registrador; Unidade de Ciclo de Dados</string>
    <string name="q44b">B)Unidade de Controle; um registrador; Unidade de Controle</string>
    <string name="q44c">C)Unidade de Controle; uma memória principal; Unidade de Controle</string>
    <string name="q44d">D)Unidade de Controle; uma memória secundária; Unidade de Ciclo de Dados</string>
    <string name="q44e">E)Unidade de Controle; um gerenciador; Unidade de Ciclo de Dados</string>
    <string name="q45">A ___________, ao receber a instrução que está armazenada em IR, a decodiﬁca e envia os sinais de controle para onde for necessário. ___________ nada mais é do que ler um código em binário e interpretar a operação relativa a esse código. Dependendo da operação, os sinais de controle podem ser ___________, por exemplo, para a ULA executar uma soma, ou para o conteúdo de um registrador ser transferido para a ULA. Ou pode ser ___________, para um dispositivo de entrada e saída, por exemplo, ou mesmo para a ___________.</string>
    <string name="q45a">A)Unidade de Controle; Decodiﬁcar; internos; externo; Memória Principal</string>
    <string name="q45b">B)Unidade de Ciclo de Dados; Decodiﬁcar; internos; externo; Memória Cache</string>
    <string name="q45c">C)Unidade de Controle; Codiﬁcar; externos; interno; Memória Principal</string>
    <string name="q45d">D)Unidade de Ciclo de Dados; Codiﬁcar; internos; externo; Memória Principal</string>
    <string name="q45e">E)Unidade de Controle; Decodiﬁcar; internos; externos; Memória Cache</string>
    <string name="q46">Toda CPU trabalha em dois ciclos principais, o ___________ e o ___________. Assim que o computador é iniciado, a CPU entra no ___________, em seguida passa para o ___________ e depois volta para o ___________. Ela continua nesse processo até que precise ser desligada, saindo do ___________ para o estado ﬁnal. Durante o Ciclo de Busca, é a Unidade de Controle que atua.</string>
    <string name="q46a">A)Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Busca; Ciclo de Busca; Ciclo de Execução</string>
    <string name="q46b">B)Ciclo de Execução; Ciclo de Execução; Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Busca</string>
    <string name="q46c">C)Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Busca</string>
    <string name="q46d">D)Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Execução</string>
    <string name="q46e">E)Ciclo de Execução; Ciclo de Busca; Ciclo de Execução; Ciclo de Execução; Ciclo de Busca; Ciclo de Execução</string>
    <string name="q47">O ___________ é lido para se saber que instrução será executada, essa instrução é trazida para o ___________ e, ﬁnalmente, é decodiﬁcada pela ___________. Assim que esse processo termina, caso a instrução não diga respeito à um laço, ou à uma repetição, o conteúdo de ___________ é incrementado. Ou seja, ___________. Assim, no próximo ___________ a instrução do endereço seguinte será carregada da memória e executada. Esse comportamento garante a característica de execução sequencial dos programas.</string>
    <string name="q47a">A)PC; IR; Unidade de Ciclo de Dados; PC; PC recebe PC + 1; Ciclo de Busca</string>
    <string name="q47b">B)IR; PC; Unidade de Controle; PC; PC recebe PC + 1; Ciclo de Execução</string>
    <string name="q47c">C)IR; PC; Unidade de Controle; IR; IR recebe IR + 1; Ciclo de Busca</string>
    <string name="q47d">D)IR; PC; Unidade de Controle; PC; IR recebe IR + 1; Ciclo de Execução</string>
    <string name="q47e">E)PC; IR; Unidade de Controle; PC; PC recebe PC + 1; Ciclo de Busca</string>
    <string name="q48">Durante o Ciclo de Execução há cinco possíveis tipos de operação que podem ser executadas: \n1. Processador e memória \n2. Processador e Entrada e Saída \n3. Processamento de Dados \n4. Controle \n5. Operações compostas \na. são operações simplesmente de processamento dos dados, como operação aritmética ou lógica sobre os registradores da CPU; \nb. trata simplesmente da transferência de dados entre CPU e memória principal; \nc. diz respeito à transferência de dados entre a CPU e um dispositivo de Entrada e Saída, como teclado, mouse, monitor, rede, impressora etc.; \nd. são operações que combinam uma ou mais instruções das outras em uma mesma operação;\ne. são instruções que servem para controlar os dispositivos do computador, como para ligar um periférico, iniciar uma operação do disco rígido, ou transferir um dado que acabou de chegar pela Internet para a Memória Principal; </string>
    <string name="q48a">A)1-a; 2-b; 3-c; 4-e; 5-d</string>
    <string name="q48b">B)1-a; 2-c; 3-b; 4-e; 5-d</string>
    <string name="q48c">C)1-b; 2-c; 3-a; 4-e; 5-d</string>
    <string name="q48d">D)1-b; 2-a; 3-c; 4-d; 5-e</string>
    <string name="q48e">E)1-c; 2-b; 3-d; 4-a; 5-e</string>
    <string name="q49">Em operações entre Processador e Memória, é necessário que dados sejam trazidos da memória para servirem de entrada para a ULA, e/ou o resultado seja levado para armazenamento na memória no ﬁnal da execução. Para isso acontecer, é executada uma ___________. Isso é determinado durante a ___________ da instrução, no ciclo de ___________. Isso acontece quando um dos parâmetros de uma operação aritmética é um endereço de memória, e não um valor diretamente, nem um registrador.</string>
    <string name="q49a">A)Busca de Dados; decodiﬁcarão; Busca de Dados</string>
    <string name="q49b">B)Busca de Instrução; decodiﬁcarão; Busca de Instrução</string>
    <string name="q49c">C)Busca de Dados; decodiﬁcarão; Busca de Instrução</string>
    <string name="q49d">D)Busca de Instrução; codiﬁcarão; Busca de Dados</string>
    <string name="q49e">E)Busca de Dados; codiﬁcarão; Busca de Instrução</string>
    <string name="q50">Como a memória é sempre mais lenta do que a CPU, instruções que necessitam ___________ são muito mais lentas do que instruções de ___________. Quanto mais acessos à memória, mais lenta a instrução. O ideal é sempre usar ___________.</string>
    <string name="q50a">A)Buscas de Instrução; Processamento de Dados; registradores</string>
    <string name="q50b">B)Buscas de Dados; Processamento de Dados; registradores</string>
    <string name="q50c">C)Buscas de Instrução; Processamento de Dados; memória Cache</string>
    <string name="q50d">D)Processamento de Dados; Buscas de Dados; memória Cache</string>
    <string name="q50e">E)Processamento de Dados; Buscas de Dados; registradores</string>
    <string name="q51">Os computadores sempre tentam passar os dados ___________ para ___________ assim que puderem, para que as próximas instruções sejam ___________.</string>
    <string name="q51a">A)da memória; a ULA; aceleradas</string>
    <string name="q51b">B)dos registradores; as memórias; aceleradas</string>
    <string name="q51c">C)da memória; os registradores; desaceleradas</string>
    <string name="q51d">D)dos registradores; a ULA; desaceleradas</string>
    <string name="q51e">E)da memória; os registradores; aceleradas</string>
    <string name="q52">Como o ___________ da CPU é fechado, ou seja, a CPU sempre ﬁca em estado de repetição até que seja desligada, ela não pode atender a nenhum evento externo que não seja a execução de um programa. Por exemplo, quando um usuário pressiona uma tecla do teclado, ou faz um movimento com o mouse, ou mesmo, quando uma mensagem chega pela Internet através da placa de rede. Se a CPU ela estiver em um ___________ ela precisará parar o que está fazendo para atender ao evento ocorrido e, só então, voltar ao ___________. Esse processo de parar o ___________ para atender a um evento externo é chamado de Interrupção.</string>
    <string name="q52a">A)Ciclo de Instrução; Ciclo de Execução; Ciclo de Busca; Ciclo de Instrução</string>
    <string name="q52b">B)Ciclo de Execução; Ciclo de Execução; Ciclo de Execução; Ciclo de Execução</string>
    <string name="q52c">C)Ciclo de Busca; Ciclo de Busca; Ciclo de Busca; Ciclo de Busca</string>
    <string name="q52d">D)Ciclo de Instrução; Ciclo de Instrução; Ciclo de Instruções; Ciclo de Instrução</string>
    <string name="q52e">E)Ciclo de Busca; Ciclo de Execução; Ciclo de Busca; Ciclo de Execução</string>
    <string name="q53">Todas as ___________ são recebidas e armazenadas internamente por um dispositivo chamado ___________. Esse dispositivo é um chip, semelhante à uma CPU, mas bem ___________. Na maioria dos computadores eles vêm soldados na Placa-Mãe, mas podem também vir dentro do chip da CPU. Toda interrupção possui um código de identiﬁcação.</string>
    <string name="q53a">A)interrupções; Gerenciador de Interrupções; mais simples</string>
    <string name="q53b">B)internações; Gerenciador de internações; mais complexas</string>
    <string name="q53c">C)interrupções; Gerenciador de Interrupções; mais simples</string>
    <string name="q53d">D)internações; Gerenciador de internações; mais simples</string>
    <string name="q53e">E)interrupções; Gerenciador de Interrupções; mais complexas</string>
    <string name="q54">Sempre que uma ___________ chega ao Gerenciador de Interrupções, ele armazena esse código em sua memória e manda ___________ para CPU através do ___________.</string>
    <string name="q54a">A)nova interrupção; um sinal; Barramento de Controle</string>
    <string name="q54b">B)nova interrupção; um mensagem; Barramento de Controle</string>
    <string name="q54c">C)nova interrupção; um mensagem; Barramento de Dados</string>
    <string name="q54d">D)nova internação; um sinal; Barramento de Dados</string>
    <string name="q54e">E)nova internação; uma mensagem; Barramento de Instruções</string>
    <string name="q55">Durante seu ___________, sempre que uma instrução é executada, antes de voltar para o ___________, a CPU checa se algum sinal de interrupção foi enviado pelo Gerenciador de Interrupção. Quando não há uma interrupção, a execução volta ao ___________ e o programa em execução continua a ser executado. Mas se houver uma interrupção, a CPU agora vai parar a execução do programa atual para atender a interrupção. Por exemplo, vamos supor que o usuário tenha pressionado uma tecla do teclado. O código armazenado pelo Gerenciador de Interrupção indica que a interrupção veio do teclado. A CPU pára sua execução do programa anterior e vai iniciar a execução de um programa especial, ___________. O código do dispositivo (aqui seria o teclado) serve para a CPU saber o endereço do Tratador de Interrupção que ela vai buscar da memória. Então, ao sair da ___________, a CPU muda o endereço do PC para o endereço do Tratador de Instrução. Assim, no Ciclo de Busca a próxima instrução a ser trazida da memória e posteriormente executada será a do tratador do teclado.</string>
    <string name="q55a">A)Ciclo de Instrução; Ciclo de Busca; Ciclo de Busca; o Tratador de Interrupção; Checagem de Interrupção</string>
    <string name="q55b">B)Ciclo de Execução; Ciclo de Busca; Ciclo de Execução; o Gerenciador de Interrupção; Verificação de Interrupção</string>
    <string name="q55c">C)Ciclo de Instrução; Ciclo de Execução; Ciclo de Busca; o Tratador de Interrupção; Checagem de Interrupção</string>
    <string name="q55d">D)Ciclo de Execução; Ciclo de Instrução; Ciclo de Instrução; o Gerenciador de Interrupção; Verificação de Interrupção</string>
    <string name="q55e">E)Ciclo de Instrução; Ciclo de Execução; Ciclo de Busca; o Tratador de Interrupção; Checagem de Interrupção</string>
    <string name="q56">Cada tipo de interrupção precisa de um tratamento especíﬁco a ser feito. No caso do teclado, o tratador vai checar que tecla foi pressionada. Isso é feito através de uma leitura à memória do teclado (sim, todos os dispositivos possuem uma pequena memória) para saber que tecla foi pressionada. Geralmente, a CPU adiciona o código da tecla pressionada num endereço especíﬁco de memória. O programa ativo no momento, vai ler esse conteúdo, executar a ação da tecla e limpar essa área de memória. Se o programa for um editor de texto, por exemplo, o código pode representar escrever a letra pressionada na posição atual do cursor dentro do texto. Quando esse processo encerra, o tratamento é encerrado, e a CPU deve voltar à execução do programa que havia sido interrompido. Isso só é possível porque, antes de passar à execução do ___________, a CPU salva os conteúdos de ___________ registradores da CPU (___________ o PC e o IR). Então, antes de devolver a execução para o programa, a CPU restaura todos os valores dos registradores antes salvos.</string>
    <string name="q56a">A)Gerenciador de Interrupção; todos os; inclusive </string>
    <string name="q56b">B)Tratador de Interrupção; todos os; inclusive </string>
    <string name="q56c">C)Tratador de Interrupção; todos os; apenas</string>
    <string name="q56d">D)Gerenciador de Interrupção; poucos; apenas </string>
    <string name="q56e">E)Tratador de Interrupção; poucos; inclusive</string>
    <string name="q57">As interrupções também ocorrem se o próprio programa em execução executar uma operação ___________. Isso é feito para evitar que a CPU entre em ___________. Por exemplo, se um programa tentar acessar uma área da memória que é proibida para ele, como a área de outro programa ou ___________. Nesse caso, o programa é interrompido e não volta mais a executar, ele é ﬁnalizado e a execução é devolvida ao Sistema Operacional. Algo semelhante ocorre em caso de defeitos em alguns dispositivos. Por exemplo, se um programa estiver lendo um arquivo que está em um pendrive, e esse pendrive é removido subitamente, uma interrupção é lançada e o programa é encerrado, já que ele não faz mais sentido estar em execução.</string>
    <string name="q57a">A)legal; erro; do Sistema Operacional</string>
    <string name="q57b">B)ilegal; loop; da BIOS</string>
    <string name="q57c">C)legal; loop; da BIOS</string>
    <string name="q57d">D)ilegal; erro; do Sistema Operacional</string>
    <string name="q57e">E)legal; erro; da BIOS</string>
    <string name="q58">O computador precisa ter memórias rápidas para reduzir o tempo dos ___________, precisam de mais registradores para usar menos a memória e também que ___________ interrupções ocorram.</string>
    <string name="q58a">A)Ciclos de Busca; muitas</string>
    <string name="q58b">B)Ciclos de Busca; poucas</string>
    <string name="q58c">C)Ciclos de Instrução; poucas</string>
    <string name="q58d">D)Ciclos de Execução; muitas</string>
    <string name="q58e">E)Ciclos de Execução; poucas</string>
    <string name="q59">Cada vez que uma interrupção ocorre, o programa deve ser ___________ e a chamada deve ser atendida. Isso vai ___________ demais o tempo de execução dos programas, dando a impressão de ___________ desempenho.</string>
    <string name="q59a">A)interrompido; atrasar; baixo</string>
    <string name="q59b">B)parado; adiantar; alto</string>
    <string name="q59c">C)pausado; atrasar; alto</string>
    <string name="q59d">D)interrompido; atrasar; baixo</string>
    <string name="q59e">E)parado; adiantar; baixo</string>
    <string name="q60">Basicamente, há dois tipos programas: </string>
    <string name="q60a">A)os orientados à CPU e os orientados a Entrada e Saída</string>
    <string name="q60b">B)os orientados à memória e os orientados a Entrada e Saída</string>
    <string name="q60c">C)os orientados à CPU e os orientados a memória</string>
    <string name="q60d">D)os orientados à Entrada e os orientados a Saída</string>
    <string name="q60e">E)os orientados à recursão e os orientados a Entrada e Saída</string>
    <string name="q61">Quando um programa é ___________, há momentos longos de processamento de CPU e curtos momentos de espera por um evento de ___________. É o exemplo de programas que fazem muitos cálculos matemáticos, como ferramentas de simulação, projetos de engenharia, computação gráﬁca e planilhas de cálculos. Inicialmente os dados de entrada são passados por um dispositivo de entrada, há longos momentos de cálculos e depois os resultados são passados para um dispositivo de entrada e saída.</string>
    <string name="q61a">A)orientado à CPU; Entrada e Saída</string>
    <string name="q61b">B)orientado à Entrada e Saída; Entrada</string>
    <string name="q61c">C)orientado à memória; Saída</string>
    <string name="q61d">D)orientado à Entrada; Entrada e Saída</string>
    <string name="q61e">E)orientado à recursão; Entrada</string>
    <string name="q62">Os programas ___________, que são aqueles chamados também de ___________, há muitos momentos de interação e uso de dispositivos de Entrada e Saída, e poucos momentos de uso de CPU. Esse é o caso de programas que utilizam muito o mouse e o teclado, como os jogos e a própria navegação na internet.</string>
    <string name="q62a">A)orientados à recursão; interativos</string>
    <string name="q62b">B)orientados à CPU; estáticos</string>
    <string name="q62c">C)orientados à CPU; interativos</string>
    <string name="q62d">D)orientados à recursão; estáticos</string>
    <string name="q62e">E)orientados à Entrada e Saída; interativos</string>
    <string name="q63">Os Sistemas Operacionais são os responsáveis por escolher que tarefa colocar para executar a cada momento e por quanto tempo ela deve executar até que uma nova tarefa entre em ___________. Assim, o papel do Sistema Operacional é fundamental e determinante no desempenho do sistema. O que ele tenta fazer no ___________ que pode, é tentar ocupar os tempos de espera de um programa com a ___________ de outro.</string>
    <string name="q63a">A)interrupção; máximo; interrupção</string>
    <string name="q63b">B)interrupção; mínimo; interrupção</string>
    <string name="q63c">C)execução; máximo; interrupção</string>
    <string name="q63d">D)interrupção; mínimo; execução</string>
    <string name="q63e">E)execução; máximo; execução</string>
    <string name="q64">___________ é obtido quando replicamos unidades do processador para que elas funcionem em ___________, ___________ assim o tempo de execução dos programas.</string>
    <string name="q64a">A)Paralelismo em Nível de Instruções; paralelo; aumentando</string>
    <string name="q64b">B)Paralelismo em Nível de Hardware; serial; reduzindo</string>
    <string name="q64c">C)Paralelismo em Nível de Instruções; serial; reduzindo</string>
    <string name="q64d">D)Paralelismo em Nível de Hardware; paralelo; reduzindo</string>
    <string name="q64e">E)Paralelismo em Nível de Instruções; paralelo; aumentando</string>
    <string name="q65">No ___________, ou ILP (do inglês, Instruction Level Parallelism), as unidades do processador ___________, mas melhores organizadas para que ___________. Há duas formas principais de implementar o ILP, uma delas é através do Pipeline e a outra é através de processadores Superescalares.</string>
    <string name="q65a">A)Paralelismo em Nível de Hardware; são duplicadas; ﬁquem ociosas</string>
    <string name="q65b">B)Paralelismo em Nível de Instruções; são duplicadas; não ﬁquem ociosas</string>
    <string name="q65c">C)Paralelismo em Nível de Hardware; não são duplicadas; ﬁquem ociosas</string>
    <string name="q65d">D)Paralelismo em Nível de Hardware; são duplicadas; não ﬁquem ociosas</string>
    <string name="q65e">E)Paralelismo em Nível de Instruções; não são duplicadas; não ﬁquem ociosas</string>
    <string name="q66">Imagine que possamos dividir o Ciclo de Instrução de um determinado processador nas cinco etapas seguintes: \n1. Carregar instrução (FI) \n2. Carregar operandos (FO) \n3. Executar instruções (EI) \n4. Escrever em memória (WM) \n5. Escrever em registrador (WR) \na. Executa operação lógica ou aritmética propriamente dita. \nb. Escreve o resultado da operação em um dos registradores, se necessário. \nc. Traz a instrução da memória para o processador, armazena em IR (essa etapa também é chamada de Fetch de Instrução) e a decodiﬁca para execução no passo seguinte. \nd. Traz os operandos da operação dos registradores para a ULA, para que a operação seja realizada sobre eles, também chamada de Fetch de Operandos. \ne. Escreve o resultado da operação em memória, se necessário. </string>
    <string name="q66a">A)1-a; 2-b; 3-c; 4-e; 5-d</string>
    <string name="q66b">B)1-b; 2-d; 3-e; 4-a; 5-c</string>
    <string name="q66c">C)1-b; 2-e; 3-a; 4-c; 5-d</string>
    <string name="q66d">D)1-c; 2-d; 3-c; 4-b; 5-a</string>
    <string name="q66e">E)1-c; 2-d; 3-a; 4-e; 5-b</string>
    <string name="q67">O Ciclos de Instrução com apenas 5 estágios é o mais simples que poderíamos imaginar (processadores convencionais, como os da Intel que usamos em nossos computadores, executam instruções em cerca de 18 etapas). Cada instrução deve passar pelos cinco passos descritos para ser executada. Suponha que cada etapa necessite de apenas 1 ciclo de clock para ser executada. Quantos ciclos seriam necessários para executar um programa de 20 instruções? </string>
    <string name="q67a">A)Cada instrução deve passar pelas cinco etapas, e cada etapa leva 1 ciclo de clock, sendo assim, o programa levará 20 vezes 5 ciclos, ou seja, 100 ciclos de clock. </string>
    <string name="q67b">B)Cada instrução deve passar pelas cinco etapas, e cada etapa leva 2 ciclo de clock, sendo assim, o programa levará 20 vezes 5 ciclos, ou seja, 200 ciclos de clock. </string>
    <string name="q67c">C)Cada instrução deve passar pelas cinco etapas, e cada etapa leva 3 ciclo de clock, sendo assim, o programa levará 20 vezes 5 ciclos, ou seja, 300 ciclos de clock. </string>
    <string name="q67d">D)Cada instrução deve passar pelas cinco etapas, e cada etapa leva 4 ciclo de clock, sendo assim, o programa levará 20 vezes 5 ciclos, ou seja, 400 ciclos de clock. </string>
    <string name="q67e">E)Cada instrução deve passar pelas cinco etapas, e cada etapa leva 5 ciclo de clock, sendo assim, o programa levará 20 vezes 5 ciclos, ou seja, 500 ciclos de clock. </string>
    <string name="q68">Levando em consideração os estágios do Ciclo de Instrução: FI, WR, EI, FO, WM. Vamos analisar o que acontece com cada etapa a medida em que o programa é executado. A primeira instrução vai passar pela etapa __________, que a leva para o IR e a decodiﬁca. Em seguida ela é passada para a etapa __________, e os dados necessários para a operação são levados dos respectivos registradores para a ULA. Agora, observe. Neste exato momento, a segunda instrução do programa está parada na memória, aguardando sua vez para ser executada. Ao mesmo tempo, a etapa __________ está ociosa. Por que a etapa __________ não pode entrar em ação e trabalhar com a segunda instrução do programa, enquanto a primeira está na etapa __________? O mesmo vai ocorrer com todas as etapas de execução da primeira instrução do programa. Ela vai ser executada na etapa __________, depois vai passar para a etapa __________ que checará se há necessidade de copiar o resultado para a memória e, ﬁnalmente, para a __________, que copiará o resultado para um dos registradores. Quando a primeira instrução estiver na etapa __________, as etapas anteriores estarão todas ociosas. Por que não aproveitar o tempo ocioso para colocar as etapas anteriores para irem adiantando a execução das próximas instruções? É isso que propõe o __________! </string>
    <string name="q68a">A)WR; FO; FI; FI; EI; EI; WM; WM; WR; Pipeline</string>
    <string name="q68b">B)FO; FO; EI; FI; FO; WR; WR; WR; FO; Pipeline</string>
    <string name="q68c">C)FO; FI; FI; FI; FO; FO; FO; WM; WR; Paginação</string>
    <string name="q68d">D)FI; FO; FI; FI; FO; EI; WM; WR; WR; Pipeline</string>
    <string name="q68e">E)FI; FI; EI; FI; EI; FI; FO; WR; FO; Paginação</string>
    <string name="q69">O __________ vai separar as etapas de execução de instruções em unidades físicas independentes, assim, uma etapa pode trabalhar com uma instrução, ao mesmo tempo em que uma outra unidade trabalha com uma outra instrução. É a mesma estratégia utilizada pela indústria de produção em massa para fabricar carros, por exemplo. Enquanto um chassi está sendo montado, outro está recebendo a carroceria, outro o motor, outro sendo pintado e outro recebendo o acabamento interno. Todas etapas trabalhando em paralelo e vários carros sendo tratados ao mesmo tempo. Esta estratégia aumenta o desempenho da execução das instruções de forma grandiosa. A primeira mudança necessária é a separação da memória em duas partes independentes (ou duas memórias mesmo). Uma parte será utilizada apenas para instruções (representadas pela palavra __________), e outra apenas para os dados (representada por __________). Isso é necessário para que a etapa FI acesse a memória para buscar a próxima instrução, ao mesmo tempo em que a WM acessa a memória para salvar o resultado de outra instrução anterior. Se houvesse apenas uma memória para dados e instruções, isso não seria possível. Essa mudança vai contra o que foi projetado na ((Arquitetura de von Neumann)), e foi considerado um grande avanço. Ela foi batizada de __________. \nOutra mudança importante foi a adição de memórias intermediárias entre cada etapa. Essas memórias são utilizadas para armazenar o resultado da etapa anterior e passá-lo para a etapa posterior no ciclo seguinte. Elas são necessárias porque as etapas não executam necessariamente sempre na mesma velocidade. Se uma etapa for concluída antes da etapa seguinte, seu resultado deve ser guardado nessas memórias para aguardar que a etapa seguinte conclua o que estava fazendo. Só então ela poderá receber o resultado da etapa anterior. \nO mesmo ocorre na produção de um carro. A etapa de instalação do motor pode ser mais rápida do que a de pintura, por exemplo. Então, se um carro acabou de receber um motor, ele deve ser guardado num local temporário até que o carro anterior tenha sua pintura concluída. Assim, a etapa de instalação do motor pode receber um novo carro. </string>
    <string name="q69a">A)Pipeline; Fetch; DMem; Arquitetura Oxford</string>
    <string name="q69b">B)Paginação; Fetch; DMem; Arquitetura Oxford</string>
    <string name="q69c">C)Pipeline; DMem; Fetch; Arquitetura Harvard</string>
    <string name="q69d">D)Paginação; DMem; Fetch; Arquitetura Harvard</string>
    <string name="q69e">E)Pipeline; Fetch; DMem; Arquitetura Harvard</string>
    <string name="q70">Como o Pipeline exemplificado, possui 5 estágios, ele precisa, no mínimo, de 5 instruções para encher o Pipeline e, a partir daí, inicia-se o ganho de desempenho. Considerando que cada etapa leve 1 ciclo de clock para ser concluída. Quantos ciclos são necessários para executar 20 instruções agora com Pipeline? No início, o Pipeline não está cheio, então a instrução I1 deve passar por todas as 5 etapas para ser concluída, levando então 5 ciclos de clock. Mas, a instrução I2 acompanhou I1 durante toda execução e terminou no ciclo seguinte, ou seja, em 6 ciclos de clock. Em seguida, a instrução I3 foi concluída em 7 ciclos de clock, I4 em 8 ciclos, I5 em 9 ciclos, assim em diante, até a conclusão da vigésima instrução, que ocorreu em __________ ciclos. \nComparado com algum exemplo sem Pipeline, que executará esse mesmo programa em __________ ciclos, o ganho foi de 4,17 vezes. Se o programa tivesse 200 instruções, levaria 1000 ciclos de clock sem Pipeline e 204 ciclos com Pipeline, o resultaria num ganho de 4,9 vezes. Onde queremos chegar com isso? \nA medida em que a quantidade de instruções aumenta, o ganho de desempenho com Pipeline vai se aproximando da quantidade de estágios, que foi 5 nesse exemplo. Então, quanto mais instruções forem executadas e mais estágios de Pipeline tiver o processador, __________ será o benefício de usar o Pipeline. </string>
    <string name="q70a">A)24; 100; maior</string>
    <string name="q70b">B)25; 50; menor</string>
    <string name="q70c">C)26; 200; maior</string>
    <string name="q70d">D)27; 150; menor</string>
    <string name="q70e">E)30; 300; maior</string>
    <string name="q71">No Pipeline uma parte da memória será utilizada apenas para instruções (___________), e outra apenas para os dados (___________). Isso é necessário para que a etapa FI acesse a memória para buscar a próxima instrução, ao mesmo tempo em que a WM acessa a memória para salvar o resultado de outra instrução anterior. Essa mudança vai contra o que foi projetado na ___________, e foi considerado um grande avanço. Ela foi batizada de ___________.</string>
    <string name="q71a">A)Fetch; DMem; Arquitetura Harvard; Arquitetura de von Neumann</string>
    <string name="q71b">B)DMem; Fetch; Arquitetura Harvard; Arquitetura de von Neumann</string>
    <string name="q71c">C)Fetch; DMem; Arquitetura de von Neumann; Arquitetura Harvard</string>
    <string name="q71d">D)DMem; Fetch; Arquitetura de von Neumann; Arquitetura Harvard</string>
    <string name="q71e">E)DMem; Fetch; Arquitetura Harvard; Arquitetura de von Newton</string>
    <string name="q72">Como o Pipeline possui ___________, ele precisa, no ___________, de 5 instruções para encher o Pipeline e, a partir daí, inicia-se o ganho de desempenho. A medida em que a quantidade de instruções ___________, o ganho de desempenho com Pipeline vai se aproximando da quantidade de estágios. Então, quanto mais instruções forem executadas e mais estágios de Pipeline tiver o processador, ___________ será o benefício de usar o Pipeline.</string>
    <string name="q72a">A)7 estágios; mínimo; aumenta; maior</string>
    <string name="q72b">B)7 estágios; máximo; diminui; menor</string>
    <string name="q72c">C)5 estágios; máximo; aumenta; menor</string>
    <string name="q72d">D)5 estágios; mínimo; aumenta; maior</string>
    <string name="q72e">E)32 estágios; mínimo; diminui; maior</string>
    <string name="q73">Infelizmente, nem sempre o processador consegue usufruir do ganho máximo de desempenho ao usar o Pipeline. Há vários riscos que podem fazer com que o Pipeline seja interrompido e precise ser reiniciado, ou impossibilitado até de iniciar. Os riscos são: \n1. Riscos Estruturais \n2. Riscos de Dados \n3. Riscos de Controle </string>
    <string name="q73a">A)3</string>
    <string name="q73b">B)1 e 2</string>
    <string name="q73c">C)1 e 3</string>
    <string name="q73d">D)2 e 3</string>
    <string name="q73e">E)1, 2 e 3</string>
    <string name="q74">___________ são limitações físicas do processador. O exemplo mais simples é a separação da memória em Memória de Dados e Memória de Instruções. Se isso não ocorrer, as etapas de FI e WM não podem ser executadas ao mesmo tempo.</string>
    <string name="q74a">A)Os Riscos Estruturais</string>
    <string name="q74b">B)Os Riscos de Dados</string>
    <string name="q74c">C)Os Riscos de Controle</string>
    <string name="q74d">D)Os Riscos de Endereço</string>
    <string name="q74e">E)Os Riscos de Instruções</string>
    <string name="q75">___________ ocorre quando uma instrução depende do resultado de uma instrução anterior que está no Pipeline e ainda não está pronta.</string>
    <string name="q75a">A)Os Riscos Estruturais</string>
    <string name="q75b">B)Os Riscos de Endereço</string>
    <string name="q75c">C)Os Riscos de Controle</string>
    <string name="q75d">D)Os Riscos de Dados</string>
    <string name="q75e">E)Os Riscos de Instruções</string>
    <string name="q76">___________ ocorre quando qualquer mudança no ﬂuxo de controle do processador. Ou seja, quando a execução deixa de ser meramente sequencial. A mudança de controle também pode ocorrer por meio de interrupção, provocada por um dispositivo de entrada e saída, ou pelo próprio Sistema Operacional, quando determina que um programa seja interrompido para passar a execução para um outro. Quando há uma mudança no ﬂuxo de execução desta maneira, todas instruções que estão no Pipeline são removidas, o ﬂuxo é modiﬁcado, e o Pipeline começa a ser preenchido todo novamente.</string>
    <string name="q76a">A)Os Riscos Estruturais</string>
    <string name="q76b">B)Os Riscos de Endereço</string>
    <string name="q76c">C)Os Riscos de Controle</string>
    <string name="q76d">D)Os Riscos de Dados</string>
    <string name="q76e">E)Os Riscos de Instruções</string>
    <string name="q77">As técnicas de Pipeline avançaram bastante e várias medidas foram tomadas para ___________ o prejuízo causado pelos riscos. Entretanto, ___________ técnica é capaz de evitar ___________ possíveis perdas de desempenho. Até boas práticas de programação podem ajudar a otimizar a execução dos programas, e os compiladores também ajudam bastante neste aspecto.</string>
    <string name="q77a">A)aumentar; nenhuma; todas as</string>
    <string name="q77b">B)amenizar; nenhuma; todas as</string>
    <string name="q77c">C)amenizar; todas as; todas as</string>
    <string name="q77d">D)amenizar; todas as; nenhuma</string>
    <string name="q77e">E)aumentar; nenhuma; nenhuma</string>
    <string name="q78">Para medir o desempenho dos computadores, três métricas principais são mais usadas: \n1. Ciclos de Clock por Instrução (CPI) \n2. Milhões de Instruções por Segundo (MIPS) \n3. Milhões de Instruções em Ponto Flutuante por Segundo (MFLOPS) \na. determina quantos ciclos de clock são necessários para executar uma determinada instrução. Vimos que o Ciclo de Instrução é organizado em várias etapas e que isso depende de instrução para instrução. Se uma instrução acessar mais memória do que outra, ela será mais lenta. Instruções que operam com Pontos Flutuantes são mais lentas do que as operações com números inteiros. Operações com números reais são mais complexas de serem resolvidas, porque devem ser realizadas para a parte fracionária e para a inteira, e depois o resultado deve ser consolidado. Assim, simulações são realizadas com um processador e são calculados quantos ciclos de clock cada tipo de instrução necessita em média para ser completada.\nb. uma alternativa para o MIPS é o MFLOPS. O MIPS é muito eﬁciente, mas não para comparar programas diferentes. Para calcular o MFLOPS, são executadas apenas instruções que operam com Ponto Flutuante e são calculados quantos segundos se passaram para cada milhão delas. A única diferença para o cálculo do MIPS é que apenas as instruções que operam com Ponto Flutuante são consideradas. Assim, CPIf diz respeito a quantos ciclos de clock em média são necessários para executar uma instrução de ponto ﬂutuante. Os computadores pessoais e comerciais de hoje trabalham na escala MFLOPS. Já os supercomputadores trabalham na escala de GFLOPS (Giga FLOPS). Aqueles computadores que lideram a lista do Top 500, e são capazes até de mudar o PIB de um país, trabalham na escala do TFLOPS (Teta FLOPS).\nc. o CPI é uma medida utilizada para medir o desempenho do processador para cada tipo de instrução, mas não é muito boa para medir o desempenho para a execução de programas, que é o objetivo de todo computador. Isso porque os programas são geralmente formados por instruções de todos os tipos, com inteiros, ponto ﬂutuante, acessando muita ou pouca memória. Outro fator é que fatores como, Pipeline, tecnologia de memória e tamanho da memória Cache, podem fazer com que uma instrução seja executada lenta agora, e rápida logo em seguida. Para contornar isso, uma métrica muito utilizada é o MIPS. Ela determina quantos Milhões de Instruções são executadas pelo computador a cada segundo. Nesse caso, programas que demandam muito esforço do computador são executados, a quantidade de instruções é contada e depois dividida pela quantidade de segundos da execução.</string>
    <string name="q78a">A)1-a; 2-b; 3-c</string>
    <string name="q78b">B)1-a; 2-c; 3-b</string>
    <string name="q78c">C)1-b; 2-a; 3-c</string>
    <string name="q78d">D)1-b; 2-c; 3-a</string>
    <string name="q78e">E)1-c; 2-a; 3-b</string>
    <string name="q79">Conhecer a ___________ é essencial para o entendimento de como as instruções são executadas pelo computador. A ___________ é a unidade interna à CPU responsável (como o próprio nome já diz) pelo controle da execução das instruções. Como a CPU é uma máquina de executar instruções, a ___________ é quem controla o principal funcionamento do computador. O projeto de uma ___________ varia de arquitetura para arquitetura, mas há alguns pontos que são comuns a todas elas. Toda ___________ trabalha com a execução de Microoperações. Cada instrução é executada através de um Ciclo de Instrução.</string>
    <string name="q79a">A)Unidade de Lógica e Aritmética</string>
    <string name="q79b">B)Unidade de Controle</string>
    <string name="q79c">C)Unidade de Ciclo de Dados</string>
    <string name="q79d">D)Unidade de armazenamento</string>
    <string name="q79e">E)Unidade de Processamento</string>
    <string name="q80">Cinco possíveis estágios para o ciclo de instrução:</string>
    <string name="q80a">A)Carrega instrução, decodiﬁca, executa, salva resultados e checa interrupção</string>
    <string name="q80b">B)Carrega instrução, codiﬁca, gerencia, salva resultados e checa interrupção</string>
    <string name="q80c">C)Carrega instrução, decodiﬁca, gerencia, salva resultados e checa execução</string>
    <string name="q80d">D)Descarrega instrução, codiﬁca, executa, salva resultados e checa execução</string>
    <string name="q80e">E)Descarrega instrução, decodiﬁca, executa, salva resultados e checa interrupção</string>
    <string name="q81">Cada estágio do Ciclo de Instrução é quebrado em sub-estágios, chamados de ___________. A ___________ é a operação atômica (indivisível) realizada pela Unidade de Controle para a execução de cada estágio. Cada vez que um estágio do Ciclo de Instrução for executado, as devidas ___________ são executadas pela Unidade de Controle. Essa organização é necessária para melhorar a organização da CPU e facilitar o projeto das Unidades de Controle. Além disso, nos projetos de Unidades de Controle modernas, é possível reutilizar ___________ de um estágio em outro. Por exemplo, para executar uma instrução, é necessário executar uma ___________ para buscar um dado que está em um registrador (ou memória) para a ULA. Se houver vários dados envolvidos, a única tarefa a ser realizada é pedir para a Unidade de Controle executar a mesma ___________ de buscar dado, mas agora com endereço diferente. Dessa maneira, todas instruções que chegam à Unidade de Controle são quebradas em estágios (lembre-se do Pipeline), que por sua vez, separados em sequências de ___________ e, só então, são executadas.</string>
    <string name="q81a">A)Micro-instruções</string>
    <string name="q81b">B)Micro-cálculos</string>
    <string name="q81c">C)Operações</string>
    <string name="q81d">D)Microoperações</string>
    <string name="q81e">E)Operandor de Dados</string>
    <string name="q82">___________: neste estágio uma nova instrução deve ser buscada da memória e trazida para a CPU para que possa ser decodiﬁcada e executada em seguida. O endereço da instrução a ser buscada está sempre no Contador de Programa (PC) e a instrução buscada da memória é armazenada no Registrador de Instrução (IR). A seguir cada Microoperação é apresentada ao lado de uma determinação do tempo em que ela será realizada. Nesse caso, três unidades de tempo são necessárias (t1, t2 e t3). Imagine que cada unidade de tempo é 1 ciclo de clock (as microoperações mais complexas levam mais tempo do que isso).\nt1: \tMAR - (PC) \n\tMemória &lt;- fetch; \nt2: \tMBR &lt;- (memória) \n\tPC &lt;- (PC) + 1 \nt3: \tIR &lt;- (MBR) \nNo tempo t1 o endereço guardado no registrador PC é copiado para o registrador MAR, que é o registrador conectado ao Barramento de Endereço. Ao mesmo tempo, a CPU envia para a memória um sinal de "fetch", indicando que precisa ser trazida uma nova instrução. No tempo t2 a memória lê o endereço contigo no Barramento de Endereço (que é sempre o mesmo de MAR), busca a instrução e a escreve no Barramento de Dados. Como o MBR sempre reﬂete aquilo que está no Barramento de Dados, o MBR agora contém a instrução trazida da memória. Esta tarefa é realizada essencialmente pela memória, a ULA está livre para executar outra Microoperação, e aproveita para adicionar 1 ao endereço do PC. Esta operação de incremento vai garantir que a próxima instrução a ser buscada será a do endereço seguinte da memória. Finalmente, no tempo t3, a instrução que foi trazida da memória e salva em MBR pode ser agora salva em IR.\nA instrução precisa sempre estar em IR porque na faze de decodiﬁcarão, a Unidade de Controle vai buscar lá que instrução deve executar. \nObserve que a mesma Microoperação poderia ser executada de forma diferente, como mostrada a seguir.\nt1: \tMAR &lt;- (PC) \n\tMemória &lt;- fetch; \nt2: \tMBR &lt;- (memória) \nt3: \tPC &lt;- (PC) +1 \n\tIR &lt;- (MBR) \nNesta segunda opção, o incremento de PC foi passado para o tempo t3, ao invés de t2, o que gera o mesmo resultado.\nA quantidade de Microoperações que podem ser executadas no mesmo ciclo de clock depende da arquitetura do processador.\nPor exemplo, se há apenas uma ULA, então só é possível executar uma única operação lógica, ou aritmética a cada ciclo de clock.\nO mesmo serve para o uso acesso à memória com MAR e MBR. Se houver um barramento exclusivo para instruções, separado do barramento de dados e uma memória de instrução separada da memória de dados (quase todos processadores hoje possuem), e então é possível buscar uma instrução no mesmo ciclo de clock que se busca um dado.</string>
    <string name="q82a">A)Execução</string>
    <string name="q82b">B)Busca indireta</string>
    <string name="q82c">C)Busca de Instrução</string>
    <string name="q82d">D)Salvar resultado</string>
    <string name="q82e">E)Salto condicional</string>
    <string name="q83">___________: outro tipo de Microoperação muito utilizado. Ela trata de buscar um dado que está na memória e trazer para a CPU para ser utilizado pela instrução. Não está diretamente na CPU (em um registrador) mas na memória.\nImagine que a instrução em questão seja a soma de 2 números A e B, ambos na memória. Esta instrução foi buscada no estágio anterior, portanto no ciclo seguinte ela estará no registrador IR. Então, os endereços de A e B estão presentes na instrução que agora está em IR. Essa busca deve então ser realizada para A e depois para B, da seguinte forma: \nt1: \tMAR &lt;- (IRendereco) \n\tMemória &lt;- read \nt2: \tMBR &lt;- (memória) \nt3: \tACC &lt;- (MBR) \nNo primeiro instante t1 o endereço do dado contido em IR é passado para o registrador de endereço MAR. Ao mesmo tempo a CPU envia para a memória um sinal de leitura (read), avisando que deve ser feita uma busca. No instante seguinte, t2, o conteúdo do dado é trazido da memória para o MBR através do Barramento de Dados, e no último passo, em t3, o conteúdo agora em MBR é levado para um registrador para que seja utilizado na operação, geralmente o Acumulador (ACC).</string>
    <string name="q83a">A)Salto condicional</string>
    <string name="q83b">B)Busca de Instrução</string>
    <string name="q83c">C)Execução</string>
    <string name="q83d">D)Salvar resultado</string>
    <string name="q83e">E)Busca indireta</string>
    <string name="q84">___________: Após a busca da instrução e dos dados necessários, é hora de executar a instrução na Microoperação de execução. Como exemplo da soma A e B, a Unidade de Controle terá que fazer a Busca Indireta de A e B para depois realizar a soma. Supondo que A seja salvo em ACC, ele deve ser transferido para outro registrador, digamos R1 antes de Busca Indireta por B. Assim, a execução seria: \nt1: \tR1 &lt;- ACC \n// Busca indireta por B: \nt2: \tMAR &lt;- (IRendereco) \n\tMemória &lt;- read \nt3: \tMBR &lt;- (memória) \nt4: \tACC &lt;- MBR \nt5: \tACC = R1 + ACC \nEm t1 o conteúdo de A salvo em ACC será transferido para o registrador R1. Nos intervalos de t2 até t4 seria feita a Busca Indireta por B. E, ﬁnalmente, no instante t5 a soma de R1 e ACC seria realizada e salva no acumulador ACC.</string>
    <string name="q84a">A)Busca indireta</string>
    <string name="q84b">B)Busca de Instrução</string>
    <string name="q84c">C)Salto condicional</string>
    <string name="q84d">D)Execução</string>
    <string name="q84e">E)Salvar resultado</string>
    <string name="q85">___________: Após o passo de execução, o conteúdo de ACC com o resultado da operação deve ser transferido para o local de destino. Se o resultado for salvo num registrador, a operação é direta e feita num único ciclo de clock. Mas se precisar salvar o resultado na memória, uma escrita indireta deverá ser realizada para salvar o conteúdo de ACC na memória.\nt1: \tMAR &lt;- (IRendereco) \nt2: \tMBR &lt;- ACC \n\tMemória &lt;- write \nPara tal, inicialmente em t1 o endereço da variável de memória que precisa ser salva é passado para o MAR. O conteúdo de ACC é passado para o MBR no ciclo seguinte (t2), ao mesmo tempo em que a CPU envia para a memória um sinal de escrita. Ao receber esse sinal, a memória traz o conteúdo de MBR e o salva no endereço representado por MAR.</string>
    <string name="q85a">A)Salvar resultado</string>
    <string name="q85b">B)Execução</string>
    <string name="q85c">C)Busca de Instrução</string>
    <string name="q85d">D)Busca indireta</string>
    <string name="q85e">E)Salto condicional</string>
    <string name="q86">___________: Uma instrução muito comum executada pelos computadores são os saltos condicionais. Ela indica que se uma determinada condição for satisfeita, a execução não deve ser a da instrução seguinte, mas a indicada pela instrução. Imagine uma instrução “Salta se zero”, com dois parâmetros, X e Y. O X seria a variável a ser testada e o Y o endereço para onde a execução deve saltar caso o valor de X seja 0.\nDesta forma, as microoperações seriam as seguinte: \n// Busca indireta por X: \nt1: \tMAR &lt;- (IRenderecoX) \n\tMemória &lt;- read \nt2: \tMBR &lt;- (Memória) \nt3: \tACC &lt;- (MBR) \nt4: \tse ACC == 0, PC = (IRenderecoY) \nInicialmente, de t1 a t3, seria buscado o conteúdo de X na memória. No último ciclo t4, o conteúdo de ACC seria comparado com 0 e se forem iguais, o conteúdo de PC será o endereço da variável Y, também presente em IR. Observe que, caso contrário, nada precisa ser feito, o PC continuará como antes e a próxima instrução depois da atual será executada.</string>
    <string name="q86a">A)Busca indireta</string>
    <string name="q86b">B)Busca de Instrução</string>
    <string name="q86c">C)Execução</string>
    <string name="q86d">D)Salvar resultado</string>
    <string name="q86e">E)Salto condicional</string>
    <string name="q87">Há quatro tipos básicos de Microoperações de uma Unidade de Controle. São eles: \n1. Transferência de dados entre registradores \n2. Transferência de dados de registrador para o exterior da CPU \n3. Transferência de dados do interior da CPU para um registrador \n4. Operação lógica e aritmética </string>
    <string name="q87a">A)1 e 2</string>
    <string name="q87b">B)1 e 3</string>
    <string name="q87c">C)1, 2 e 3</string>
    <string name="q87d">D)1, 2 e 4</string>
    <string name="q87e">E)1, 2, 3 e 4</string>
    <string name="q88">A ___________ é a mais simples das Microoperações e geralmente é feita num único ciclo de clock.</string>
    <string name="q88a">A)operações lógica e aritméticas</string>
    <string name="q88b">B)transferência de dados entre registrador</string>
    <string name="q88c">C)Transferência de dados de registrador para o exterior da CPU</string>
    <string name="q88d">D)Transferência de dados do exterior da CPU para um registrador</string>
    <string name="q88e">E)Microoperação</string>
    <string name="q89">A ___________ pode ser mais complexa. Para facilitar muitos computadores mapeiam todos dispositivos de Entrada e Saída com se fossem memória. Ou seja, para a CPU, enviar um dado para um dispositivo seria como escrever um dado na memória, bastando usar um endereço diferente. Isso facilita bastante a operação da Unidade de Controle, mas pode limitar a quantidade de endereços de memória disponíveis para os programas.</string>
    <string name="q89a">A)Microoperação</string>
    <string name="q89b">B)transferência de dados entre registrador</string>
    <string name="q89c">C)Transferência de dados do exterior da CPU para um registrador</string>
    <string name="q89d">D)Transferência de dados de registrador para o exterior da CPU</string>
    <string name="q89e">E)operações lógica e aritméticas</string>
    <string name="q90">As operações de ___________ são complexas, porque levam um tempo não conhecido para serem executadas. Se o dado estiver na memória Cache o acesso é mais rápido, se estiver na Memória Principal levará mais tempo, e se tiver num dispositivo externo, um Disco Rígido, por exemplo, pode levar ainda mais.</string>
    <string name="q90a">A)Transferência de dados de registrador para o exterior da CPU</string>
    <string name="q90b">B)transferência de dados entre registrador</string>
    <string name="q90c">C)Transferência de dados do exterior da CPU para um registrador</string>
    <string name="q90d">D)operações lógica e aritméticas</string>
    <string name="q90e">E)Microoperação</string>
    <string name="q91">As ___________ podem ser mais rápidas ou mais lentas dependendo de cada uma delas. Operações com números de Ponto Flutuante tendem a levar mais tempo do que aquelas com números inteiros. Já as operações trigonométricas são as mais lentas que o computador pode operar.</string>
    <string name="q91a">A)operações lógica e aritméticas</string>
    <string name="q91b">B)Transferência de dados de registrador para o exterior da CPU</string>
    <string name="q91c">C)Transferência de dados do exterior da CPU para um registrador</string>
    <string name="q91d">D)transferência de dados entre registrador</string>
    <string name="q91e">E)Microoperação</string>
    <string name="q92">A execução das Microoperações ___________ é ordenada pela Unidade de Controle. Isso é feito no estágio de ___________, a partir da leitura da instrução presente em IR. O primeiro passo da ___________ é ler o código da instrução para conhecer seu tipo. Dependendo do tipo, a instrução é quebrada numa quantidade especíﬁca de Estágios e cada estágio no seu respectivo grupo de Microoperações. Cada vez que uma Microoperação se encerra, a Unidade de Controle checa qual será a próxima e envia os sinais para os devidos registradores, para ULA e dispositivos envolvidos, como memória ou dispositivos de Entrada e Saída.</string>
    <string name="q92a">A)sempre; Decodiﬁcação; decodiﬁcarão</string>
    <string name="q92b">B)nunca; Decodiﬁcação; Codiﬁcarão</string>
    <string name="q92c">C)sempre; Decodiﬁcação; Codiﬁcarão</string>
    <string name="q92d">D)sempre; Codiﬁcação; decodiﬁcarão</string>
    <string name="q92e">E)nunca; Codiﬁcação; decodiﬁcarão</string>
    <string name="q93">Podemos dizer que a Unidade de Controle possui duas funções principais, a ___________ e o ___________. No ___________ a Unidade de Controle deve saber o exato momento que uma Microoperação concluiu para executar a próxima, e quando a ___________ Microoperação for executada, iniciar um novo Estágio, e quando o último Estágio for concluído, executar a próxima instrução do programa.</string>
    <string name="q93a">A)execução; sequenciamento das instruções; execução; primeira</string>
    <string name="q93b">B)execução; sequenciamento das instruções; sequenciamento das instruções; última</string>
    <string name="q93c">C)interrupção; sequenciamento das instruções; sequenciamento das instruções; última</string>
    <string name="q93d">D)interrupção; sequenciamento das instruções; interrupção; última</string>
    <string name="q93e">E)interrupção; sequenciamento das instruções; sequenciamento das instruções; primeira</string>
    <string name="q94">Considere um processador que executa suas instruções em cinco estágios de execução: \n-Busca de Instrução \n-Decodiﬁca Instrução \n-Busca de Dados \n-Executa Instrução \n-Salva Resultados \nCada instrução do programa é decomposta em microoperações que são executadas, geralmente, uma a cada ciclo de clock. \nSendo, assim, suponha que o programa a ser executado está na memória de acordo com os dados a seguir. Cada instrução ﬁca armazenada em um endereço de memória, assim como as variáveis envolvidas.\nEndereço \tInstrução ou Dado\nFF01 \tA = B x C\nFF02 \tB = A + 2\nFF03 \t15 // valor de A\nFF04 \t2 // valor de B\nFF05 \t4 // valor de C\n ___________ \nPara que esse programa seja executado, é necessário que o registrador PC contenha o endereço FF01 para que a primeira instrução do nosso programa nessa buscada e executa. O início de execução de um programa é causado por uma ação do usuário (quando ele clica no ícone de um programa, por exemplo), pelo Sistema Operacional ou um por um outro programa. Uma vez que o PC tenha o endereço FF01, na próxima instrução a ser buscada, a Unidade de Controle irá executar as seguintes instruções: \nt1: \tX \n\tMemória &lt;- fetch; \nt2: \tMBR &lt;- ‘A = B x C’ \n\tPC &lt;- PC + 1 \nt3: \tIR &lt;- MBR \nNeste exemplo, no tempo t1, MAR recebeu o endereço contido em PC, ou seja, FF01. Nesse mesmo instante, a Unidade de Controle envia o sinal ‘fetch’ para memória, que por sua vez, passa o conteúdo do endereço FF01 para o registrador MBR no instante t2 seguinte. Aproveitando o tempo, enquanto o conteúdo da memória era trazido para o MBR, a Unidade de Controle incrementou o endereço de PC para FF02. Só no tempo t3 a instrução está pronta em MBR e é então copiada para IR para que possa ser Decodiﬁcada na próxima microoperação.\nDecodiﬁcação \nDurante a decodiﬁcação não são executadas Microoperações. A instrução que acabou de ser copiada para IR é analisada e a Unidade de Controle vai então escolher que Microoperações serão executadas nas etapas seguintes.\nBusca de Dados \nNas próximas etapas, será necessário buscar os dados necessários para a execução da instrução. Como os dados envolvidos (B e C) estão na memória, e não em registradores, serão necessárias duas Buscas Indiretas. A instrução na verdade nunca chega como sendo ‘A = B x C’. Ao invés disso, ela seria armazenada como ‘(FF03) = (FF04) x (FF05). Por questões didáticas, utilizamos ainda as variáveis A, B e C.\nPara buscar o conteúdo da variável B, as seguintes Microoperações são executadas.\nt4: \tMAR &lt;- (FF04) \n\tY \nt5: \tMBR &lt;- 2 \nt6: \tACC &lt;- MBR \nAqui, o endereço FF04 é passado para o MAR para que seja buscado na memória no tempo t4, em seguida é enviado um sinal de leitura para a memória. Ao receber o sinal de leitura, a memória busca o conteúdo do endereço FF04 e o copia para dentro da CPU, no registrador MBR no instante t5. Finalmente, no tempo t6, o conteúdo de MBR (valor 2) é copiado para o registrador acumulador (ACC).\nO próximo passo seria buscar o conteúdo da variável C de forma análoga a utilizada para buscar B.\nt7: \tMAR &lt;- (FF05) \n\tMemória &lt;- read \nt8: \tMBR &lt;- 4 \nt9: \tW \nPerceba que na última Microoperação o conteúdo de C foi copiado para R1, para não sobreescrever e perder o conteúdo da variável B que foi armazenado em ACC.\nExecução \nNo próximo passo, a instrução precisa ser executada. Isso é feito em um único passo no tempo t10, onde ACC, que agora mantém o conteúdo da variável B é multiplicado por R1, que possui o conteúdo da variável C.\nt10: \tACC &lt;- ACC x R1\nSalva Resultados \nFinalmente, o resultado da operação precisa ser salvo na variável A. Para tal, o endereço de A (FF03) é copiado para o registrador de endereço (MAR) no instante t11. No instante t12 seguinte, o resultado da operação aritmética armazenado em ACC é copiado para o registrador de dados (MBR). Neste mesmo instante, a Unidade de Controle envia o sinal de escrita para a memória, que localiza o endereço FF03 e escreve nele o resultado da operação aritmética que foi salvo em ACC, ou seja, oito (8).\nt11: \tMAR &lt;- (FF03) \nt12: \tZ \n\tMemória &lt;- write</string>
    <string name="q94a">A)X = MAR &lt;- PC; Y = Memória &lt;- write; W = R1 &lt;- MBR; Z = MAR &lt;- ACC</string>
    <string name="q94b">B)X = MBR &lt;- PC; Y = Memória &lt;- read; W = R1 &lt;- MBR; Z = MBR &lt;- ACC</string>
    <string name="q94c">C)X = MAR &lt;- PC; Y = Memória &lt;- read; W = R1 &lt;- MBR; Z = MBR &lt;- ACC</string>
    <string name="q94d">D)X = MBR &lt;- PC; Y = Memória &lt;- write; W = R1 &lt;- MBR; Z = MAR &lt;- ACC</string>
    <string name="q94e">E)X = MAR &lt;- PC; Y = Memória &lt;- read; W = R1 &lt;- MAR; Z = MAR &lt;- ACC</string>
    <string name="q95">Instrução completa \nPodemos agora visualizar a seguir como a primeira instrução do programa (A = B x C) foi executada em microoperações.\n// Busca de Instrução \nt1: \tMAR &lt;- PC \n\tX; \nt2: \tMBR &lt;- \'A = B x C\' \n\tPC &lt;- PC + 1 \nt3: \tIR &lt;- MBR \n//Busca de Dados (B) \nt4: \tMAR &lt;- (FF04) \n\tMemória &lt;- read \nt5: \tMBR &lt;- 2 \nt6: \tY \n//Busca de Dados (C) \nt7: \tW \n\tMemória &lt;- read \nt8: \tMBR &lt;- 4 \nt9: \tR1 &lt;- MBR \n//Execução \nt10: \tZ \n//Salva resultados \nt11: \tMAR &lt;- (FF03) \nt12: \tMBR &lt;- ACC \n\tMemória &lt;- write \nA primeira instrução foi ﬁnalizada em 12 passos. Se cada passo for 1 ciclo de clock, então temos 12 ciclos do relógio para concluir essa instrução. A segunda instrução do programa (B = A + 2) é muito semelhante, e também precisará de 12 passos para ser executada. Esse é um ótimo exercício para você praticar. Ao ﬁnal a memória estará diferente de como iniciou, e deverá estar com os conteúdos apresentados abaixo:\nEndereço \tInstrução ou Dado\nFF01 \tA = B x C\nFF02 \tB = A + 2\nFF03 \t8 // valor de A\nFF04 \t10 // valor de B\nFF05 \t4 // valor de C \nt1: \tMAR &lt;- PC \n\tX; \nt2: \tMBR &lt;- \'A = B x C\' \n\tPC &lt;- PC + 1 \nt3: \tIR &lt;- MBR \n//Busca de Dados (B) \nt4: \tMAR &lt;- (FF04) \n\tMemória &lt;- read \nt5: \tMBR &lt;- 2 \nt6: \tY \n//Busca de Dados (C) \nt7: \tW \n\tMemória &lt;- read \nt8: \tMBR &lt;- 4 \nt9: \tR1 &lt;- MBR \n//Execução \nt10: \tZ \n//Salva resultados \nt11: \tMAR &lt;- (FF03) \nt12: \tMBR &lt;- ACC \n\tMemória &lt;- write \nA primeira instrução foi ﬁnalizada em 12 passos. Se cada passo for 1 ciclo de clock, então temos 12 ciclos do relógio para concluir essa instrução. A segunda instrução do programa (B = A + 2) é muito semelhante, e também precisará de 12 passos para ser executada. Esse é um ótimo exercício para você praticar. Ao ﬁnal a memória estará diferente de como iniciou, e deverá estar com os conteúdos apresentados abaixo:\nEndereço \tInstrução ou Dado\nFF01 \tA = B x C\nFF02 \tB = A + 2\nFF03 \t8 // valor de A\nFF04 \t10 // valor de B\nFF05 \t4 // valor de C</string>
    <string name="q95a">A)X = Memória &lt;- fetch; Y = MAR &lt;- (FF05); W = ACC &lt;- MBR; Z = ACC &lt;- ACC x R1</string>
    <string name="q95b">B)X = ACC &lt;- ACC x R1; Y = ACC &lt;- MBR; W = MAR &lt;- (FF05); Z = Memória &lt;- fetch</string>
    <string name="q95c">C)X = Memória &lt;- fetch; Y = ACC &lt;- ACC x R1; W = MAR &lt;- (FF05); Z = ACC &lt;- MBR</string>
    <string name="q95d">D)X = ACC &lt;- ACC x R1; Y = MAR &lt;- (FF05); W = ACC &lt;- MBR; Z = Memória &lt;- fetch</string>
    <string name="q95e">E)X = Memória &lt;- fetch; Y = ACC &lt;- MBR; W = MAR &lt;- (FF05); Z = ACC &lt;- ACC x R1</string>
    <string name="q96">O termo Conjunto de Instruções vem do inglês ___________. ___________ é a interface entre os softwares que serão executados pelo processador e o próprio processador. Ele deﬁne todas instruções de máquina serão interpretadas pela Unidade de Controle e executadas. Podemos então deﬁnir Conjunto de Instruções como sendo a coleção completa de todas instruções reconhecidas e executadas pela CPU. Esse Conjunto de instruções, também chamado de ___________, é o ponto inicial para o projeto de uma arquitetura e é essencial na deﬁnição de qualidade do sistema como um todo.</string>
    <string name="q96a">A)Instruction Bit Architecture (IBA); IBA; Código de Máquina</string>
    <string name="q96b">B)Instruction Set Architecture (ISA); ISA; Código de Máquina</string>
    <string name="q96c">C)Instruction Set Architecture (ISA); ISA; Código de Computador</string>
    <string name="q96d">D)Instruction Sort Architecture (ISA); ISA; Código de Máquina</string>
    <string name="q96e">E)Instruction Sort Architecture (ISA); ISA; Código de Computador</string>
    <string name="q97">Um Conjunto de Instruções pode ser classiﬁcado como uma das quatro arquiteturas: \n1. Arquitetura de Palha \n2. Baseada em Acumulador \n3. Registrador-Registrador ou Load/Store \n4. Registrador-Memória</string>
    <string name="q97a">A)3 e 4</string>
    <string name="q97b">B)1, 2 e 3</string>
    <string name="q97c">C)1, 2 e 4</string>
    <string name="q97d">D)2, 3 e 4</string>
    <string name="q97e">E)1, 2, 3 e 4</string>
    <string name="q98">A ___________ é a mais simples possível. Os dados necessários para a execução das operações pela ULA são provenientes de registradores especiais organizados na forma de uma pilha. Note que toda operação é realizada entre o registrador que indica o Topo de Pilha (apontado pelo registrador TOS) e o registrador seguinte. Esse conjunto de instruções é muito simples porque a Unidade de Controle nunca precisa decodiﬁcar a instrução para saber quais registradores serão utilizados nas operações lógicas e aritméticas. Sempre será o topo da pilha e o registrador seguinte.</string>
    <string name="q98a">A)Arquitetura Load/Store ou Arquitetura Registrador-Registrador</string>
    <string name="q98b">B)Arquitetura de Pilha</string>
    <string name="q98c">C)arquitetura baseada em Acumulador</string>
    <string name="q98d">D)arquitetura von Neumann</string>
    <string name="q98e">E)Arquitetura Registrador-Memória</string>
    <string name="q99">Na ___________ uma complexidade é adicionada. Um dos dados vem sempre do registrador Acumulador, mas o outro é mais livre. Esse segundo dado vem da memória, mas poderia vir de um outro registrador designado na instrução. Neste caso, a instrução a ser decodiﬁcada pela Unidade de Controle precisará trazer de onde vem o segundo dado a ser utilizado, já que o primeiro é sempre proveniente do Acumulador.</string>
    <string name="q99a">A)Arquitetura Load/Store ou Arquitetura Registrador-Registrador</string>
    <string name="q99b">B)Arquitetura de Pilha</string>
    <string name="q99c">C)arquitetura baseada em Acumulador</string>
    <string name="q99d">D)arquitetura von Neumann</string>
    <string name="q99e">E)Arquitetura Registrador-Memória</string>
    <string name="q100">A terceira arquitetura mais complexa é chamada ___________. Nesta arquitetura, todas operações lógicas e aritméticas executadas pela ULA são provenientes de dois registradores a serem determinados pela instrução. A única forma de acessar dados da memória é através de duas instruções especiais: LOAD, para ler da memória e STORE para escrever o conteúdo de um registrador na memória. Assim, toda instrução a ser decodiﬁcada pela CPU deverá indicar o endereço de dois registradores que serão utilizados na operação lógica ou aritmética, ou um endereço de memória se a instrução for um LOAD ou um STORE.</string>
    <string name="q100a">A)Arquitetura Load/Store ou Arquitetura Registrador-Registrador</string>
    <string name="q100b">B)Arquitetura de Pilha</string>
    <string name="q100c">C)arquitetura baseada em Acumulador</string>
    <string name="q100d">D)arquitetura von Neumann</string>
    <string name="q100e">E)Arquitetura Registrador-Memória</string>
    <string name="q101">___________, é a arquitetura mais complexa. Esta arquitetura permite que a ULA execute operações lógicas e aritméticas envolvendo ao mesmo tempo um registrador indicado pela instrução e um conteúdo proveniente da memória. Esse tipo de instrução deve então trazer, em seu conteúdo, o código do registrador a ser utilizado e o endereço de memória do segundo dado. É muito importante aqui observar que arquiteturas mais simples, como a de Pilha por exemplo, fazem com as instruções a serem decodiﬁcadas pela Unidade de Controle sejam muito simples. Com instruções simples, a própria Unidade de Controle será simples, pequena e barata de produzir. Por outro lado, instruções simples resultam em operações limitadas. Assim, uma tarefa básica, como somar dois números, em uma Arquitetura de Pilha vai necessitar que pelo menos 4 operações sejam reali- zadas: colocar na pilha o primeiro dado, colocar na pilha o segundo dado, somar os dois elementos da pilha, salvar o resultado na pilha. Essa mesma operação numa arquitetura Registrador-Memória seria executada numa instrução única, indicando o registrador utilizado para ser o primeiro dado, o endereço de memória do segundo dado e o registrador que vai guardar o resultado.</string>
    <string name="q101a">A)Arquitetura Load/Store ou Arquitetura Registrador-Registrador</string>
    <string name="q101b">B)Arquitetura de Pilha</string>
    <string name="q101c">C)arquitetura baseada em Acumulador</string>
    <string name="q101d">D)arquitetura von Neumann</string>
    <string name="q101e">E)Arquitetura Registrador-Memória</string>
    <string name="q102">A escolha da arquitetura é uma questão importantíssima de projeto e geralmente baseia-se na relação entre o desempenho que se quer atingir e o preço do processador ao ﬁnal. Após deﬁnida a arquitetura do Conjunto de Instruções, o projetista deve cuidar do projeto das instruções propriamente ditas. Neste projeto cinco pontos devem ser contemplados: \n1. Modelo de Memória \n2. Tipos de Dados \n3. Formato das Instruções \n4. Tipo de Instruções \n5. Modo de Endereçamento </string>
    <string name="q102a">A)1, 2 e 3</string>
    <string name="q102b">B)2, 3 e 4</string>
    <string name="q102c">C)1, 2, 3 e 5</string>
    <string name="q102d">D)1, 2, 4 e 5</string>
    <string name="q102e">E)1, 2, 3, 4 e 5</string>
    <string name="q103">O modelo de memória deﬁne para cada instrução de onde vem e para onde vão os dados. Os dados podem vir da ___________. Além disso, o projeto do ISA deve deﬁnir alguns pontos cruciais.</string>
    <string name="q103a">A)memória principal</string>
    <string name="q103b">B)memória Cache</string>
    <string name="q103c">C)memória principal e memória Cache</string>
    <string name="q103d">D)memória pincipal, memória Cache e registrador</string>
    <string name="q103e">E)memória principal, ou memória Cache, de um registrador, ou de um dispositivo de Entrada e Saída</string>
    <string name="q104">As memórias geralmente são organizadas em ___________. Isso signiﬁca que o byte é a ___________ unidade de acesso à memória, e assim, cada endereço de memória acessa um ___________.</string>
    <string name="q104a">A)bytes; menor; byte</string>
    <string name="q104b">B)Kilobytes; menor; Kilobyte</string>
    <string name="q104c">C)bytes; maior; byte</string>
    <string name="q104d">D)Kilobytes; maior; Kilobyte</string>
    <string name="q104e">E)Megabytes; menor; byte</string>
    <string name="q105">Uma variável inteira, por exemplo, pode ser declarada como um byte, ou um inteiro curto de 2 bytes, um inteiro de 4 bytes, ou até mesmo um inteiro longo de 8 bytes. Se o conjunto de instruções ﬁxar que a memória será apenas acessada de forma alinhada, signiﬁca que um dado ___________ ultrapassar uma linha. Assim, os dados de 4 bytes ___________ obrigatoriamente ser armazenados nos endereços 0, 4, 8, 12, 16 etc. Esta decisão visa facilitar e acelerar o trabalho do processador ao acessar a memória. Cada vez que a memória precisar ser acessada para buscar um número de 4 bytes, o processador deve apenas veriﬁcar se o endereço é um múltiplo de 4. Se ele ___________, o acesso é negado e o programa é encerrado. A desvantagem desta abordagem é que muitas áreas podem ﬁcar desperdiçadas. Por exemplo, se um dado de 2 bytes é armazenado no endereço 4, os Bytes 0 e 1 são utilizados, mas os Bytes 2 ﬁcam disponíveis. Mesmo assim, se um dado de 4 bytes precisar ser armazenado, ele não poderá ser feito em uma posição livre múltipla de 4 (0, 8, 12, 6 etc.), como por exemplo, salvando os dois primeiros bytes nos endereços 6 e 7 e os outros 2 bytes nos endereços 8 e 9.</string>
    <string name="q105a">A)não pode; não deverão; não for</string>
    <string name="q105b">B)pode; deverão; for</string>
    <string name="q105c">C)não pode; não deverão; for</string>
    <string name="q105d">D)pode; não deverão; não for</string>
    <string name="q105e">E)não pode; deverão; não for</string>
    <string name="q106">Se o conjunto de instruções permitir o acesso ___________, todas as restrições se acabam e os dados podem ser acessados em quaisquer posições. O uso da memória termina tendo um maior aproveitamento, já que ___________ áreas livres existirão. O problema agora é com o desempenho. Todo processador acessa a memória através de um barramento. Para otimizar o acesso, os barramentos geralmente são largos o suﬁciente para trazer uma linha inteira de memória, ou mais. Com a ___________ ﬁca mais fácil, porque para buscar um dado a CPU só precisa saber em que linha ele está, daí é só trazê-la para a CPU.</string>
    <string name="q106a">A)alinhado à memória; mais; memória alinhada</string>
    <string name="q106b">B)não alinhado à memória; mais; memória alinhada</string>
    <string name="q106c">C)alinhado à memória; menos; memória não alinhada</string>
    <string name="q106d">D)não alinhado à memória; menos; memória alinhada</string>
    <string name="q106e">E)alinhado à memória; mais; memória não alinhada</string>
    <string name="q107">Na ___________, quando um dado é buscado a CPU precisa saber em que linha ele está, em que posição exatamente começa, se ele invade a próxima linha, e onde termina. Esta operação é mais uma responsabilidade para a CPU e torna o processo de leitura mais ___________. Processadores da arquitetura Intel, por exemplo, utilizam ___________, porque percebeu-se que o ganho com o desperdício de memória não compensa o tempo gasto buscando dados em linhas diferentes.</string>
    <string name="q107a">A)memória alinhada; lento; memórias alinhadas</string>
    <string name="q107b">B)memória não alinhada; lento; memórias alinhadas</string>
    <string name="q107c">C)memória alinhada; lento; memórias não alinhadas</string>
    <string name="q107d">D)memória não alinhada; rápido; memórias alinhadas</string>
    <string name="q107e">E)memória alinhada; rápido; memórias não alinhadas</string>
    <string name="q108">Outra decisão importante com relação ao acesso à memória é se a faixa de endereços da memória de dados será a mesma da ___________. Desde a criação das Arquiteturas Harvard (em substituição às de Von Neumann) os dados ___________ a serem armazenados em áreas de memória separadas das instruções. Isso ___________ principalmente no Pipeline, porque a CPU pode, no mesmo ciclo, buscar uma instrução e buscar os dados de uma outra instrução.</string>
    <string name="q108a">A)memória de instruções; passaram; ajuda</string>
    <string name="q108b">B)memória de instruções; passaram; não ajuda</string>
    <string name="q108c">C)memória de gerenciamento; passaram; ajuda</string>
    <string name="q108d">D)memória de gerenciamento; não passaram; ajuda</string>
    <string name="q108e">E)memória de instruções; não passaram; não ajuda</string>
    <string name="q109">Na deﬁnição do Conjunto de Instruções o projetista deve decidir como serão os endereços dessas áreas de memória. Por exemplo, se uma memória tiver 2 milhões de bytes (2MB), como cada byte possui ___________, ela terá endereços de 0 a 1.999.999. Digamos que a primeira parte de memória seja para os dados e a segunda para as instruções. Neste caso, haverá duas opções. A memória pode ser organizada como ___________ de endereços, então os endereços de 0 a 999.999 serão utilizados para armazenar os dados, e os endereços de 1.000.000 a 1.999.999 armazenarão as instruções. O problema desta abordagem é que neste sistema só poderá haver 1 milhão de dados e 1 milhão de instruções. Não será possível o armazenamento de nenhuma instrução a mais do que isso, mesmo que a área de dados esteja com posições disponíveis. Como solução, o Conjunto de Instruções pode deﬁnir instruções especiais para buscar dados e para buscar instruções. Quando uma instrução de busca for decodiﬁcada a Unidade de Controle saberá que se trata de um dado ou um endereço e vai buscar a informação exatamente na memória especiﬁcada. No exemplo dado, as instruções ﬁcariam armazenadas na memória de instrução nos endereços de entre 0 e 1.999.999, e os dados na memória de dados também no endereço de 0 e 1.999.999. Mas observe que a memória do exemplo só possui 2 milhões de bytes (2MB), mesmo assim, neste exemplo, o sistema seria capaz de endereçar 4 milhões de bytes (4MB). Isso a tornaria pronta para ___________ do espaço de memória.</string>
    <string name="q109a">A)um endereço; várias faixas; um aumento futuro</string>
    <string name="q109b">B)uma instrução; várias faixas; uma redução futura</string>
    <string name="q109c">C)um endereço; uma faixa única; um aumento futuro</string>
    <string name="q109d">D)uma instrução; uma faixa única; um aumento futuro</string>
    <string name="q109e">E)um endereço; várias faixas; uma redução futura</string>
    <string name="q110">No início do desenvolvimento dos computadores, os engenheiros projetistas tiveram que tomar uma decisão simples, mas muito importante. Quando temos dados que ocupam mais de um byte devemos começar salvando os bytes mais signiﬁcativos, ou os menos signiﬁcativos? Esta decisão ___________ o desempenho ou o custo dos sistemas. É simplesmente uma decisão que precisa ser tomada. Aqueles projetos que adotaram a abordagem de salvar os dados a partir dos bytes ___________ foram chamados de Big Endian, enquanto que aqueles que adotaram iniciar pelo byte ___________ foram chamados de Little Endian. Imagine que uma instrução pede para que a palavra UFPB seja salva no endereço 8 da memória. Uma palavra pode ser vista como um vetor de caracteres, onde cada caracter ocupa 1 byte. No caso do ___________, o byte mais signiﬁcativo (o mais a esquerda) é o que representa a letra U. Desta forma, ele é armazenado no Byte mais a esquerda, seguido pela letra F, a letra P e a letra B. Já na abordagem ___________ a mesma palavra é armazenada iniciando pelo byte menos signiﬁcativo, da direita para a esquerda. Apesar de parecer estranho, note que o que muda é a localização dos Bytes 0, 1, 2 e 3. Comparando as abordagens Big Endian e Little Endian no exemplo, em ambos a letra U é armazenada no Byte 0, a F no Byte 1, a P no Byte 2 e a B no Byte 3. A diferença é que no Little Endian os bytes são contados da direita para a esquerda.</string>
    <string name="q110a">A)afeta em todo; menos signiﬁcativos; mais signiﬁcativo; Big Endian; Little Endian</string>
    <string name="q110b">B)não afeta em nada; menos signiﬁcativos; mais signiﬁcativo; Big Endian; Little Endian</string>
    <string name="q110c">C)não afeta em nada; mais signiﬁcativos; menos signiﬁcativo; Little Endian; Big Endian</string>
    <string name="q110d">D)afeta em todo; mais signiﬁcativos; menos signiﬁcativo; Little Endian; Big Endian</string>
    <string name="q110e">E)não afeta em nada; mais signiﬁcativos; menos signiﬁcativo; Big Endian; Little Endian</string>
    <string name="q111">A forma de acesso aos registradores também é essencial para a deﬁnição ___________. Cada endereço é referenciado através de um código, como se fosse um ___________, assim como nas memórias. O Conjunto de Instruções deve deﬁnir quantos endereços de registradores serão possíveis e o tamanho deles, e as políticas de acesso. Essas decisões são de ___________ importância para o projeto do Conjunto de Instruções e do processador como um todo.</string>
    <string name="q111a">A)das instruções de máquina; dado; extrema</string>
    <string name="q111b">B)das instruções de máquina; endereço; extrema</string>
    <string name="q111c">C)das instruções de máquina; endereço; pouca</string>
    <string name="q111d">D)das memórias da máquina; dado; extrema</string>
    <string name="q111e">E)das memórias da máquina; endereço; pouca</string>
    <string name="q112">Quando escrevemos programas em linguagens de programação somos habituados a utilizar diversos tipos de dados, como inteiros, caracteres, pontos ﬂutuantes e endereços. O que muitos esquecem, ou não sabem, é esses tipos são deﬁnidos ___________, no momento do projeto do Conjunto de Instruções. Os tipos mais comuns de dados são:\n1. Inteiros\n2. Decimais\n3. Pontos ﬂutuantes\n4. Caracteres\n5. Dados lógicos\nCada um destes dados pode ainda possuir diversas variantes, como por exemplo:\na. Inteiros e Pontos ﬂutuantes: ___________ sinal, curto, médio ou grande\nb. Caracteres: ASCII, Unicode ou outras\nc. Dados lógicos: booleanos ou mapas de ___________</string>
    <string name="q112a">A)pelo processador; com e sem; bits</string>
    <string name="q112b">B)pelo registrador; com e sem; bits</string>
    <string name="q112c">C)pelo processador; com; bytes</string>
    <string name="q112d">D)pelo registrador; com e sem; bytes</string>
    <string name="q112e">E)pelo processador; sem; bits</string>
    <string name="q113">O ___________ de máquina pode adotar todos os tipos e variedades, ou um subconjunto delas. Se um processador ___________ um tipo de dado, o compilador deverá oferecer uma alternativa ao programador e, no momento de compilação, fazer a relação entre o tipo utilizado na linguagem de programação e o tipo existente na linguagem de ___________.</string>
    <string name="q113a">A)Conjunto de Instruções; não utilizar; alto nível</string>
    <string name="q113b">B)Conjunto de Instruções; não utilizar; máquina</string>
    <string name="q113c">C)Conjunto de Endereços; utilizar; alto nível</string>
    <string name="q113d">D)Conjunto de Endereços; não utilizar; máquina</string>
    <string name="q113e">E)Conjunto de Instruções; utilizar; máquina</string>
    <string name="q114">Sempre que for determinado que um tipo de dado será utilizado pelo processador, é também necessário que se criem ___________ para manipular esses dados. Por exemplo, se for deﬁnido que a arquitetura vai suportar números de ponto ﬂutuante de 32 bits, será necessário também criar ___________ para executar operações aritméticas com esses números, criar ___________ para armazena-los e ___________ para transporta-los. É uma decisão de impacto em todo o projeto do processador.</string>
    <string name="q114a">A)instruções; instruções; registradores; endereços</string>
    <string name="q114b">B)endereços; endereços; registradores; barramentos</string>
    <string name="q114c">C)instruções; instruções; endereços; barramentos</string>
    <string name="q114d">D)endereços; endereços; registradores; barramentos</string>
    <string name="q114e">E)instruções; instruções; registradores; barramentos</string>
    <string name="q115">É preciso deﬁnir quais serão os formatos de instrução aceitos pela Unidade de Controle. No geral, toda instrução de máquina deve ter pelo menos o código da operação (ou Opcode) e os endereços para os parâmetros necessários, que podem ser registradores, posições de memória ou endereços de dispositivos de Entrada e Saída. Nesta deﬁnição de formatos é necessário que se deﬁna quantos endereços cada instrução poderá trazer. Para ilustrar, suponha que na linguagem de alto nível a operação A=B+C seja escrita e precise ser compilada. Se o Conjunto de Instruções adotar instruções com 3 endereços, ﬁca simples. O código da operação de soma é ADD e com 3 endereços ela ﬁcaria algo semelhante a:\nX\nOnde A, B e C são endereços que podem ser de memória, registrador ou dispositivo de Entrada e Saída. Mas se o Conjunto de Instruções suportar apenas 2 endereços, ele pode adotar que o resultado sempre será salvo no endereço do primeiro parâmetro, sendo assim, a instrução teria que ser compilada da seguinte forma:\nY\nADD R, C\nMOV R, A \nA instrução MOV teve de ser adicionada para copiar o conteúdo de B para R (um registrador qualquer). Em seguida a instrução ADD R, C é executa, que soma o conteúdo de R com C e salva o resultado em R. No ﬁnal, a instrução MOV é chamada novamente para salvar o resultado de R em A e ﬁnalizar a instrução. Note que todas instruções neste exemplo utilizaram no máximo 2 endereços.\nSe a arquitetura utilizar instruções de apenas 1 endereço, será necessário utilizar uma arquitetura baseada em Acumulador e toda operação será entre o Acumulador e um endereço, e o resultado será também salvo no acumulador. Assim, a instrução A=B+C seria compilada como:\nZ\nADD B\nADD C\nSTO A\nAqui, quatro instruções foram necessárias. A primeira zera o conteúdo do Acumulador (ACC). A segunda soma o Acumulador com o conteúdo apontado pelo endereço B e salva o resultado no Acumulador. A terceira soma o conteúdo do Acumulador com C e salva no Acumulador e, por ﬁm, a última instrução transfere o resultado do Acumulador para o endereço de A. Note aqui também que todas instruções não passaram de um endereço para os parâmetros.</string>
    <string name="q115a">A)X = ADD A, B, C; Y = MOV B, R; Z = ZER A, C</string>
    <string name="q115b">B)X = ADD A, B, R; Y = MOV B, R; Z = ZER A, C</string>
    <string name="q115c">C)X = ADD A, B, C; Y = MOV B, R; Z = ZER ACC</string>
    <string name="q115d">D)X = ADD A, B, R; Y = MOV B, R; Z = ZER ACC</string>
    <string name="q115e">E)X = ADD A, B, C; Y = MOV R, B; Z = ZER ACC</string>
    <string name="q116">Uma forma de realizar a operação  A=B+C seria não utilizar endereços em suas instruções principais. Isso é possível se for utilizada uma Arquitetura Baseada em Pilha. Neste caso, duas instruções são adicionadas: POP e PUSH. A instrução PUSH adiciona um valor ao topo da pilha, enquanto que POP remove um elemento do topo da pilha e adiciona seu conteúdo em um endereço. Dessa forma, a instrução seria compilada assim:___________\nNeste caso a primeira instrução colocou o conteúdo do endereço de B na pilha, a segunda instrução fez o mesmo com C. A terceira instrução é a única que não precisa de endereço. Ela faz a soma com os dois últimos valores adicionados à pilha (B e C, no caso) e salva o resultado de volta na pilha. A instrução PUSH vai remover o último valor da pilha (resultado da soma) e salvar na variável endereçada por A.</string>
    <string name="q116a">A) \nPOP B\nPUSH C\nADD\nPOP A </string>
    <string name="q116b">B) \nPOP B\nPOP C\nADD\nPUSH C</string>
    <string name="q116c">C) \nPOP B\nPUSH A\nADD\nPUSH A</string>
    <string name="q116d">D) \nPOP B\nPOP C\nADD\nPUSH A</string>
    <string name="q116e">E) \nPOP B\nPOP C\nADD\nPOP A</string>
    <string name="q117">Quanto menos endereços, mais ___________ são as instruções. Isso é ___________ porque a Unidade de Controle ___________ de muito processamento para executá-las. Por outro lado, o programa compilado se torna maior e termina consumindo mais ciclos. </string>
    <string name="q117a">A)simples; bom; não precisará</string>
    <string name="q117b">B)complexas; bom; não precisará</string>
    <string name="q117c">C)complexas; ruim; não precisará</string>
    <string name="q117d">D)simples; ruim; precisará</string>
    <string name="q117e">E)simples; bom; precisará</string>
    <string name="q118">Geralmente as arquiteturas adotam abordagem ___________. Por exemplo, aquelas que suportam instruções com 2 endereços geralmente também suportam instruções com 1 endereço e com nenhum. Isso também é bastante interessante, porque torna o processador bastante versátil. Por outro lado, aumenta a ___________ da Unidade de Controle. Cada instrução que for executada precisa antes ser classiﬁcada e depois despachada para uma unidade de execução ___________.</string>
    <string name="q118a">A)mistas; simplicidade; especíﬁca</string>
    <string name="q118b">B)simples; complexidade; especíﬁca</string>
    <string name="q118c">C)mistas; complexidade; especíﬁca</string>
    <string name="q118d">D)simples; complexidade; genérica</string>
    <string name="q118e">E)mistas; complexidade; genérica</string>
    <string name="q119">Além de deﬁnir como serão as instruções, é necessário também deﬁnir que tipos de instruções serão executadas pelo processador. Os principais tipos de instrução são:\n1. Movimentação de dados\nb. Como os dados serão transferidos interna e externamente ao processador.\n2. Aritméticas\nd. Que operações serão realizadas, como exponenciais, trigonométricas, cálculos com pontos ﬂutuantes, com e sem sinais, com números curtos e longos etc.\n3. Lógicas\na. AND, OR, NOT e XOR.\n4. Conversão\nc. De caracteres para números, de inteiros para reais, decimal para binário etc.\n5. Entrada e Saída\nf. Haverá instruções especíﬁcas ou haverá um controlador especíﬁco, como um DMA (Direct Memory Access).\n6. Controle\ng. Instruções para controlar os dispositivos diversos do computador.\n7. Transferência de Controle\ne. Como a execução deixará um programa para passar para outro, para interromper um programa, chamar subprogramas, instruções de desvio e de interrupção.</string>
    <string name="q119a">A)1-b; 2-d; 3-a; 4-c; 5-f; 6-g; 7-e</string>
    <string name="q119b">B)1-b; 2-d; 3-a; 4-c; 5-f; 6-g; 7-e</string>
    <string name="q119c">C)1-c; 2-d; 3-e; 4-a; 5-g; 6-f; 7-b</string>
    <string name="q119d">D)1-c; 2-e; 3-a; 4-b; 5-g; 6-f; 7-d</string>
    <string name="q119e">E)1-d; 2-e; 3-b; 4-g; 5-f; 6-a; 7-c</string>
    <string name="q120">Por último, no projeto de um Conjunto de Instruções é necessário determinar de que forma os endereços das instruções serão acessados. Ou seja, o que cada endereço de parâmetros de uma instrução podem representar. Ou seja, o que cada endereço de parâmetros de uma instrução podem representar. Os principais modos de endereçamento são: \n1. Imediato \n2. Indireto e Direto por Registrador \n3. Indireto e Indireto por Registrador \n4. Indexado e Indexado por Registrador</string>
    <string name="q120a">A)1 e 2</string>
    <string name="q120b">B)1 e 3</string>
    <string name="q120c">C)1, 2 e 3</string>
    <string name="q120d">D)1, 3 e 4</string>
    <string name="q120e">E)1, 2, 3 e 4</string>
    <string name="q121">O ___________ é o mais simples possível e indica que o endereço na verdade é uma constante e pode ser utilizada imediatamente. Por exemplo, na instrução a seguir: \nADD A, 5, 7 \nSigniﬁca que a variável A deve receber o conteúdo da soma de 5 com 7. O endereços 5 e 7 são considerados Imediatos, já que não representam um endereço, e sim uma constante.</string>
    <string name="q121a">A)endereçamento indireto e direto por Registrador</string>
    <string name="q121b">B)endereçamento Imediato</string>
    <string name="q121c">C)endereçamento Direto por Registrador</string>
    <string name="q121d">D)endereçamento Direto</string>
    <string name="q121e">E)endereçamento Indireto</string>
    <string name="q122">No ___________ o endereço representa um endereço de memória, como mostrado na instrução a seguir:\nADD A, B, 7 \nNeste exemplo, o valor 7 continua sendo endereçamento de forma imediata, mas os endereços de A e B são endereços de memória e por isso, são chamados de Endereços Diretos.</string>
    <string name="q122a">A)endereçamento Indireto</string>
    <string name="q122b">B)endereçamento Direto</string>
    <string name="q122c">C)endereçamento Imediato</string>
    <string name="q122d">D)endereçamento indireto e direto por Registrador</string>
    <string name="q122e">E)endereçamento Direto por Registrador</string>
    <string name="q123">No ___________ os endereços representam registradores, e poderíamos ver o exemplo citado da seguinte forma: \nADD R1, R2, C \nNeste exemplo R1 e R2 são códigos para registradores e o endereçamento é chamado Direto por Registrador, enquanto que C é acessado através de Endereçamento Direto.</string>
    <string name="q123a">A)endereçamento Direto por Registrador</string>
    <string name="q123b">B)endereçamento Direto</string>
    <string name="q123c">C)endereçamento Indireto</string>
    <string name="q123d">D)endereçamento Imediato</string>
    <string name="q123e">E)endereçamento indireto e direto por Registrador</string>
    <string name="q124">O ___________ é aplicado quando é necessário que um acesso Direto seja feito antes para buscar o endereço alvo e só então o acesso é feito. O exemplo a seguir mostra um caso onde este endereçamento é utilizado.\nADD A, (B), 7 \nNeste exemplo o endereço B entre parêntesis representa o acesso indireto. Isso indica que primeiramente o endereço de B deve ser acessado, mas lá não está o conteúdo a ser somado com 7, mas o endereço de memória onde o valor deverá ser encontrado. Este tipo de endereçamento é muito utilizado nas linguagens de programação para representar variáveis dinâmicas através de apontadores (ou ponteiros).</string>
    <string name="q124a">A)endereçamento Direto por Registrador</string>
    <string name="q124b">B)endereçamento Imediato</string>
    <string name="q124c">C)endereçamento Indireto</string>
    <string name="q124d">D)endereçamento Direto</string>
    <string name="q124e">E)endereçamento indireto e direto por Registrador</string>
    <string name="q125">No ___________, o exemplo a seguir o valor sete não é somado ao conteúdo de R1, mas ao dado que está na memória no endereço apontado por R1.\nADD A, (R1), 7</string>
    <string name="q125a">A)endereçamento Direto</string>
    <string name="q125b">B)endereçamento indireto por registrador</string>
    <string name="q125c">C)endereçamento Direto por Registrador</string>
    <string name="q125d">D)endereçamento indexado</string>
    <string name="q125e">E)o endereçamento Indexado por Registrador</string>
    <string name="q126">Neste modo de endereçamento é necessário indicar o endereço do dado e um valor chamado Deslocamento. No exemplo a seguir, o endereçamento é aplicado para B[5].\nADD A, B[5], 7 \nIsso indica que o dado a ser utilizado está no endereço B de memória adicionado de 5 posições. Ou seja, se a variável B estiver no endereço 1002 de memória, o valor B[5] estará no endereço 1007. O endereço de B é chamado de Endereço Base e o valor 5 é chamado de Deslocamento. Para realizar este endereçamento é necessário um somador que não seja a ULA para agilizar o processamento e realizar cada deslocamento. Este tipo de endereçamento é utilizado quando são utilizadas instruções de acesso a vetores.</string>
    <string name="q126a">A)endereçamento Direto por Registrador</string>
    <string name="q126b">B)endereçamento indireto por registrador</string>
    <string name="q126c">C)endereçamento indexado</string>
    <string name="q126d">D)endereçamento Direto</string>
    <string name="q126e">E)o endereçamento Indexado por Registrador</string>
    <string name="q127">Há também a possibilidade de realizar ___________, que utiliza um registrador ao invés da memória para armazenar o Endereço Base, como exibido a seguir: \nADD A, R1[5], 7 </string>
    <string name="q127a">A)endereçamento indireto por registrador</string>
    <string name="q127b">B)endereçamento indexado</string>
    <string name="q127c">C)endereçamento Direto por Registrador</string>
    <string name="q127d">D)endereçamento Direto</string>
    <string name="q127e">E)o endereçamento Indexado por Registrador</string>
    <string name="q128">O projeto do Conjunto de Instruções inicia com a escolha de uma entre duas abordagens, a abordagem RISC e a CISC. O termo RISC é a abreviação de Reduced Instruction Set Computer, ou Computador de Conjunto de Instruções Reduzido e CISC vem de Complex Instruction Set Computer, ou Computador de Conjunto de Instruções Complexo. Um computador RISC parte do pressuposto de que um conjunto ___________. Os computadores CISC visam criar arquiteturas ___________. Com programas mais curtos, os computadores CISC precisariam acessar menos a memória para buscar instruções e seriam mais rápidos.</string>
    <string name="q128a">A)simples de instruções vai resultar numa Unidade de Controle simples, barata e rápida; complexas o bastante a ponto de facilitar a construção dos compiladores, assim, programas complexos são compilados em programas de máquina mais curtos</string>
    <string name="q128b">B)complexa de instruções vai resultar numa Unidade de Controle complexa, cara, mas rápida; complexas o bastante a ponto de facilitar a construção dos compiladores, assim, programas complexos são compilados em programas de máquina mais curtos</string>
    <string name="q128c">C)simples de instruções vai resultar numa Unidade de Controle simples, barata e rápida; simples o bastante a ponto de facilitar a construção dos compiladores, assim, programas simples são compilados em programas de máquina mais curtos</string>
    <string name="q128d">D)simples de instruções vai resultar numa Unidade de Controle complexa, barata e rápida; simples o bastante a ponto de facilitar a construção dos compiladores, assim, programas complexos são compilados em programas de máquina mais curtos</string>
    <string name="q128e">E)complexa de instruções vai resultar numa Unidade de Controle simples, cara, mas rápida; complexas o bastante a ponto de facilitar a construção dos compiladores, assim, programas complexos são compilados em programas de máquina mais longos</string>
    <string name="q129">Os dados abaixo resume as principais características dos computadores RISC em comparação com os CISC. \n1. RISC \n2. CISC\na. Tipos de Dados: Muito variada\nb. Tipos de Dados: Pouca variedade \nc. Arquitetura: Registrador-Registrador \nd. Formato das Instruções: Instruções poucos endereços\ne. Arquitetura: Registrador-Memória\nf. Formato das Instruções: Instruções com muitos endereços\ng. Estágios de Pipeline: Entre 4 e 10 \nh. Acesso aos dados: Via registradores\ni. Estágios de Pipeline: Entre 20 e 30\nj. Acesso aos dados: Via memória \nk. Modo de Endereçamento: Pouca variedade \nl. Modo de Endereçamento: Muita variedade</string>
    <string name="q129a">A)1: a, d, b, h, g, k; 2: c, f, e, l, j, i</string>
    <string name="q129b">B)1: b, d, g, h, j, k; 2: a, c, e, f, i, l</string>
    <string name="q129c">C)1: c, b, d, g, h, k; 2: a, e, f, i, j, l</string>
    <string name="q129d">D)1: d, e, f, g, h, k; 2: a, b, c, i, j, l</string>
    <string name="q129e">E)1: e, f, g, h, k, l; 2: a, b, c, d, i, j</string>
    <string name="q130">Os processadores RISC geralmente adotam arquiteturas mais simples e que acessam menos a memória, em favor do acesso aos registradores. A arquitetura Registrador-Registrador é mais adotada, enquanto que os computadores CISC utilizam arquiteturas Registrador-Memória. Como as arquiteturas RISC visam Unidades de Controle mais simples, rápidas e baratas, elas geralmente optam por instruções mais simples possível, com pouca variedade e com poucos endereços. A pouca variedade dos tipos de instrução e dos modos de endereçamento, além de demandar uma Unidade de Controle mais simples, também traz outro importante benefício, que é a ___________. Como as intrusões variam pouco de uma para outra, é mais fácil para a Unidade de Controle prever quantos ciclos serão necessários para executa-las. Esta ___________ traz benefícios ___________ para o ganho de desempenho com o Pipeline. Ao saber quantos ciclos serão necessários para executar um estágio de uma instrução, a Unidade de Controle saberá exatamente quando será possível iniciar o estágio de uma próxima instrução.</string>
    <string name="q130a">A)imprevisibilidade; previsibilidade; diretos</string>
    <string name="q130b">B)previsibilidade; previsibilidade; diretos</string>
    <string name="q130c">C)previsibilidade; imprevisibilidade; diretos</string>
    <string name="q130d">D)previsibilidade; previsibilidade; indiretos</string>
    <string name="q130e">E)previsibilidade; imprevisibilidade; indiretos</string>
    <string name="q131">As arquiteturas CISC investem em Unidades de Controle poderosas e capazes de executar tarefas complexas como a Execução Fora de Ordem e a Execução Superescalar. Na execução Fora de Ordem, a Unidade de Controle analisa uma sequência de instruções ao mesmo tempo. Muitas vezes há dependências entre uma instrução e a seguinte, impossibilitando que elas sejam executadas em Pipeline. Assim, a Unidade de Controle busca outras instruções para serem executadas que ___________ as próximas da sequência e que ___________ dependentes das instruções atualmente executadas. Isso faz com que um programa não seja executado na mesma ordem em que foi compilado. A Execução Superescalar é a organização do processador em diversas unidades de execução, como Unidades de Pontos Flutuante e Unidades de Inteiros. Essas unidades trabalham simultaneamente. Enquanto uma instrução é executada por uma das unidades de inteiros, outra pode ser executada por uma das unidades de Pontos Flutuantes. Com a execução Fora de Ordem junto com a Superescalar, instruções que ___________ na sequência deﬁnida podem ser executadas para evitar que as unidades de execução ﬁquem ociosas. Estas características de complexidade tornam os estágios de Pipeline dos processadores CISC mais longos, em torno de 20 a 30 estágios. Isto porque estas abordagens de aceleração de execução devem ser adicionadas no processo de execução.</string>
    <string name="q131a">A)não são; não sejam; não estão</string>
    <string name="q131b">B)são; sejam; estão</string>
    <string name="q131c">C)não são; sejam; estão</string>
    <string name="q131d">D)são; não sejam; estão</string>
    <string name="q131e">E)são; sejam; não estão</string>
    <string name="q132">Os processadores RISC trabalham com estágios mais curtos em relação ao CISC, em torno de 4 a 10 estágios. Os processadores CISC utilizam mais ___________, enquanto que os processadores RISC utilizam mais ___________. Isso porque os processadores CISC trabalham com um maior volume de instruções e dados simultaneamente. Esses dados não poderiam ser armazenados em ___________, devido à sua elevada quantidade e são, geralmente, armazenados em ___________. Enquanto que os processadores RISC trabalham com menos instruções e dados por vez, o que possibilita a utilização predominante de ___________.</string>
    <string name="q132a">A)memória Cache; registradores; registradores; memória Cache; registradores</string>
    <string name="q132b">B)memória principal e Cache; registradores; memória Cache; memória Cache; memória Cache</string>
    <string name="q132c">C)memória Cache; registradores; registradores; memória Cache; memória Cache</string>
    <string name="q132d">D)memória principal e Cache; registradores; registradores; memória Cache; registradores</string>
    <string name="q132e">E)memória principal e Cache; memória Cache; memória Cache; registradores; memória Cache</string>
    <string name="q133">Aﬁnal, qual a melhor abordagem? \nSempre que este assunto é apresentado aos alunos, surge a pergunta crucial sobre qual é a melhor abordagem, a RISC ou a CISC? Esta é uma pergunta difícil e sem resposta deﬁnitiva. A melhor resposta que acho é de que depende do uso que se quer fazer do processador. Processadores RISC geralmente resultam em ___________. Os processadores CISC trabalham com ___________.</string>
    <string name="q133a">A)projetos menores, mais baratos e que consumem mais energia. Isso torna-os muito interessante para dispositivos móveis e computadores portáteis mais simples; clock muito baixo, são mais caros e mais poderosos no que diz respeito a desempenho. Entretanto, eles são maiores e consomem mais energia, o que os torna mais indicados para computadores de mesa e notebooks mais poderosos, além de servidores e computadores proﬁssionais</string>
    <string name="q133b">B)projetos menores, mais caros e que consumem menos energia. Isso torna-os muito interessante para dispositivos móveis e computadores portáteis mais simples; clock muito elevado, são mais baratos e mais poderosos no que diz respeito a desempenho. Entretanto, eles são menores e consomem menos energia, o que os torna mais indicados para computadores de mesa e notebooks mais poderosos, além de servidores e computadores proﬁssionais</string>
    <string name="q133c">C)clock muito elevado, são mais baratos e mais poderosos no que diz respeito a desempenho. Entretanto, eles são maiores e consomem mais energia, o que os torna mais indicados para computadores de mesa e notebooks mais poderosos, além de servidores e computadores proﬁssionais; projetos menores, mais baratos e que consumem menos energia. Isso torna-os muito interessante para dispositivos móveis e computadores portáteis mais simples</string>
    <string name="q133d">D)clock muito elevado, são mais caros e mais poderosos no que diz respeito a desempenho. Entretanto, eles são maiores e consomem mais energia, o que os torna mais indicados para computadores de mesa e notebooks mais poderosos, além de servidores e computadores proﬁssionais; projetos menores, mais baratos e que consumem menos energia. Isso torna-os muito interessante para dispositivos móveis e computadores portáteis mais simples</string>
    <string name="q133e">E)projetos menores, mais baratos e que consumem menos energia. Isso torna-os muito interessante para dispositivos móveis e computadores portáteis mais simples; clock muito elevado, são mais caros e mais poderosos no que diz respeito a desempenho. Entretanto, eles são maiores e consomem mais energia, o que os torna mais indicados para computadores de mesa e notebooks mais poderosos, além de servidores e computadores proﬁssionais </string>
    <string name="q134">Os processadores CISC iniciaram com processadores mais ___________ e depois foram incorporando mais funcionalidades. Os fabricantes, como a Intel e a AMD, precisavam sempre criar novos projetos mas mantendo a compatibilidade com as gerações ___________. Ou seja, o Conjunto de Instruções executado pelo 486 precisa também ser executado pelo Pentium para os programas continuassem compatíveis. O Pentium IV precisou se manter compatível ao Pentium e o Duo Core é compatível com o Pentium IV. Isso tornou o projeto dos processadores da Intel e AMD muito complexos, mas ___________ eﬁcientes.</string>
    <string name="q134a">A)complexos; posteriores; não pouco</string>
    <string name="q134b">B)simples; anteriores; pouco</string>
    <string name="q134c">C)complexos; anteriores; pouco</string>
    <string name="q134d">D)simples; anteriores; não pouco</string>
    <string name="q134e">E)complexos; anteriores; não pouco</string>
    <string name="q135">Os computadores líderes mundiais em competições de desempenho computacional utilizam processadores ___________. Já o foco dos processadores ___________ está na simplicidade e previsibilidade. Além do benefício da previsibilidade do tempo de execução ao Pipeline, ele também é muito interessante para aplicações industriais. Algumas dessas aplicações são chamadas de ___________. Essas aplicações possuem como seu requisito principal o tempo para realizar as tarefas. Assim, o Sistema Operacional precisa saber com quantos milissegundos um programa será executado. Isso só é possível com processadores ___________, com ___________ estágios de Pipeline, ___________ tipos de instrução, execução em ordem etc. Mesmo que os processadores ___________ sejam mais lentos do que os ___________, eles são mais utilizados nessas aplicações críticas e de tempo real, como aplicações industriais, de automação e robótica.</string>
    <string name="q135a">A)RISC; CISC; Aplicações de Tempo Real; RISC; poucos; poucos; RISC; CISC</string>
    <string name="q135b">B)CISC; RISC; Aplicações de Tempo Irreal; CISC; poucos; poucos; CISC; RISC</string>
    <string name="q135c">C)CISC; RISC; Aplicações de Tempo Real; RISC; poucos; poucos; RISC; CISC</string>
    <string name="q135d">D)RISC; CISC; Aplicações de Tempo Real; CISC; muitos; muitos; CISC; RISC</string>
    <string name="q135e">E)CISC; RISC; Aplicações de Tempo Real; RISC; muitos; muitos; RISC; CISC</string>
    <string name="q136">Sistema de Memória é uma das principais partes do computador, juntamente com o processador. Todos programas e seus dados são mantidos no Sistema de Memória e ele é responsável por entregar o mais rapidamente para o processador quando solicitado. ___________ uma tarefa simples porque as memórias tendem a ser muito mais ___________ do que o processador e sua tecnologia ___________ avançado tão rapidamente quanto a dos processadores.</string>
    <string name="q136a">A)É; rápidas; tem</string>
    <string name="q136b">B)Não é; lentas; não tem </string>
    <string name="q136c">C)É; rápidas; não tem</string>
    <string name="q136d">D)Não é; lentas; tem</string>
    <string name="q136e">E)É; lentas; não tem</string>
    <string name="q137">Em todo sistema computacional, a memória é componente essencial e de extrema relevância para o bom funcionamento do computador. Com o passar dos anos, as memórias evoluíram bastante e são formadas por vários componentes numa chamada Hierarquia de Memória. As memórias de mais velozes possuem custo por bit maior, devido às suas tecnologias, mais avançadas e mais complexas para fabricação.  As tecnologias mais avançadas até o momento são as chamadas ___________. Elas são mais utilizadas em registradores e memórias Cache. Por serem mais caras, elas estão presentes nos computadores em quantidades menores, para não encarecer demais o projeto. </string>
    <string name="q137a">A)DDR-DRAM (Double-Data Rate SDRAM)</string>
    <string name="q137b">B)SDRAM (Synchronous Dynamic RAM)</string>
    <string name="q137c">C)SRAM (Static Random-Access Memory)</string>
    <string name="q137d">D)DRAM (Static Random-Access Memory)</string>
    <string name="q137e">E)ROM (Read-Only Memory)</string>
    <string name="q138">A memória principal é fabricada utilizando tecnologia ___________. Por serem de tecnologia menos soﬁsticada, são mais lentas, mas mais baratas. Por isso elas são montadas em maior quantidade do que as memórias Cache e os registradores.</string>
    <string name="q138a">A)DDR-DRAM (Double-Data Rate SDRAM)</string>
    <string name="q138b">B)SDRAM (Synchronous Dynamic RAM)</string>
    <string name="q138c">C)SRAM (Static Random-Access Memory)</string>
    <string name="q138d">D)DRAM (Static Random-Access Memory)</string>
    <string name="q138e">E)ROM (Read-Only Memory)</string>
    <string name="q139">As Memórias Secundárias são formadas por tecnologias de ___________. Suas principais características são o baixo preço por bit, baixo preço e, por consequência, alta capacidade. Além disso, as Memórias Secundárias são memórias não voláteis, ou seja, seus conteúdos são preservados mesmo com a interrupção da fonte de energia.</string>
    <string name="q139a">A)DDR-DRAM (Double-Data Rate SDRAM)</string>
    <string name="q139b">B)SDRAM (Synchronous Dynamic RAM)</string>
    <string name="q139c">C)memórias Magnéticas e Ópticas</string>
    <string name="q139d">D)DRAM (Static Random-Access Memory)</string>
    <string name="q139e">E)ROM (Read-Only Memory)</string>
    <string name="q140">Devido ao avanço da complexidade das memórias dos computadores, elas são organizadas formando o chamado Sistema de Memória. O Sistema de Memória se inspirou no sistema de memória do corpo humano, onde lembranças mais recentes são armazenadas em memórias menores de curta duração e lembranças mais antigas e pertinentes são armazenadas em memórias de longa duração e maior capacidade. No sistema computacional o Sistema de Memória se baseia no ___________, que se divide em ___________ e ___________.</string>
    <string name="q140a">A)Princípio da Localidade; Serviçal; Espacial</string>
    <string name="q140b">B)Princípio da Regionalidade; Temporal; Regional</string>
    <string name="q140c">C)Princípio da Localidade; Regional; Espacial</string>
    <string name="q140d">D)Princípio da Regionalidade; Temporal; Regional</string>
    <string name="q140e">E)Princípio da Localidade; Temporal; Espacial</string>
    <string name="q141">O ___________ diz que um dado acessado recentemente tem mais chances de ser usado novamente, do que um dado usado há mais tempo. Isso é verdade porque as variáveis de um programa tendem a ser acessadas várias vezes durante a execução de um programa, e as instruções usam bastante comandos de repetição e sub-programas, o que faz instruções serem acessadas repetidamente. Sendo assim, o Sistema de Memória tende a manter os dados e instruções recentemente acessados no topo da Hierarquia de Memória.</string>
    <string name="q141a">A)Princípio da Localidade Computacional</string>
    <string name="q141b">B)Princípio da Localidade Temporal</string>
    <string name="q141c">C)Princípio da Localidade Regional</string>
    <string name="q141d">D)Princípio da Localidade Espacial</string>
    <string name="q141e">E)Princípio da Localidade Federal</string>
    <string name="q142">O ___________ diz que há uma probabilidade de acesso maior para dados e instruções em endereços próximos àqueles acessados recentemente. Isso também é verdade porque os programas são sequenciais e usam de repetições. Sendo assim, quando uma instrução é acessada, a instrução com maior probabilidade de ser executada em seguida, é a instrução logo a seguir dela. Para as variáveis o princípio é semelhante. Variáveis de um mesmo programa são armazenadas próximas uma às outras, e vetores e matrizes são armazenados em sequência de acordo com seus índices. Baseado neste princípio, o Sistema de Memória tende a manter dados e instruções próximos aos que estão sendo executados no topo da Hierarquia de Memória.</string>
    <string name="q142a">A)Princípio da Localidade Computacional</string>
    <string name="q142b">B)Princípio da Localidade Temporal</string>
    <string name="q142c">C)Princípio da Localidade Regional</string>
    <string name="q142d">D)Princípio da Localidade Espacial</string>
    <string name="q142e">E)Princípio da Localidade Federal</string>
    <string name="q143">O ponto inicial da memória é a ___________. Todo programa para ser executado deve ser armazenado nesta memória, com todo seus dados e instruções. Devido ao ___________, sempre que o processador solicita um dado/instrução da memória, ele e seus vizinhos (___________) são copiados para a Memória Cache no nível superior a seguir da hierarquia, Cache L2, por exemplo. Uma parte menor deste bloco é transferido para o nível seguinte (Cache L1, por exemplo), e uma parte ainda menor (porções individuais) é transferida para registradores. Quando o processador vai acessar um endereço de memória, ele faz uma consulta no sentido inverso, do topo da hierarquia até a base. Primeiro ele busca o conteúdo nos registradores. Se não encontrar, ele vai buscar no primeiro nível de Cache. Se não encontrar, ele busca no próximo nível de Cache e, por ﬁm, na Memória Principal. O grande problema é que os níveis superiores da Hierarquia de Memória possuem capacidade cada vez menores a medida que se aproximam do topo. Isso implica na falta de capacidade de armazenar todos dados e instruções que estão sendo executadas pelo processador. Por isso, o sistema deve decidir o que é mais relevante e ﬁca nos níveis mais altos, e o que é menos relevante e deve ﬁcar nos níveis inferiores da hierarquia. Perceba que tudo é uma questão de aposta.</string>
    <string name="q143a">A)Memória Cache; Princípio da Localidade; Localidade Temporal</string>
    <string name="q143b">B)Memória Principal; Princípio da Localidade; Localidade Espacial</string>
    <string name="q143c">C)Memória Principal; Princípio da Localidade; Localidade Temporal</string>
    <string name="q143d">D)Memória Cache; Princípio da Localidade; Localidade Espacial</string>
    <string name="q143e">E)Memória Principal; Princípio da Regionalidade; Localidade Temporal</string>
    <string name="q144">Tudo o que o processador possui a seu favor é o ___________, mas que se baseia em probabilidade. Há uma probabilidade de um endereço próximo (temporal e espacialmente) a um que foi acessado, ser acessado também, mas não há garantias. Muitas vezes ele acerta, mas muitas outras ele erra, e quem perde é o ___________.</string>
    <string name="q144a">A)Princípio da Localidade Espacial; desempenho geral do sistema</string>
    <string name="q144b">B)Princípio da Localidade Temporal; desempenho geral do sistema</string>
    <string name="q144c">C)Princípio da Localidade; desempenho geral do sistema</string>
    <string name="q144d">D)Princípio da Localidade Espacial; desempenho geral da empresa</string>
    <string name="q144e">E)Princípio da Localidade; desempenho geral da empresa</string>
    <string name="q145">Como fazer para aumentar a probabilidade de um endereço ser encontrado no topo da Hierarquia de Memória? A resposta é ___________, mas ___________! Deve-se investir em registradores e ___________ maiores.</string>
    <string name="q145a">A)simples; não barata; memórias Cache</string>
    <string name="q145b">B)complexa; não barata; memórias Cache</string>
    <string name="q145c">C)simples; não barata; memórias principais</string>
    <string name="q145d">D)complexa; barata; memórias principais</string>
    <string name="q145e">E)simples; barata; memórias Cache</string>
    <string name="q146">Quando as memórias estão cheias, o Sistema de Memória possui uma tarefa difícil, que é remover um conteúdo considerado menos relevante no momento, e substituir por um outro mais relevante naquele momento. A única memória que continua com uma cópia de todos os conteúdos é a ___________. A escolha de qual conteúdo deve ser removido se baseia no ___________, mas há diversas formas de implementar o algoritmo de ___________ de conteúdos, que também podem inﬂuenciar no desempenho do sistema.</string>
    <string name="q146a">A)Memória Cache; Princípio da Localidade; substituição</string>
    <string name="q146b">B)Memória Cache; Princípio da Localidade Temporal; substituição</string>
    <string name="q146c">C)Memória Principal; Princípio da Localidade; interrupção</string>
    <string name="q146d">D)Memória Principal; Princípio da Localidade; substituição</string>
    <string name="q146e">E)Memória Principal; Princípio da Localidade Espacial; interrupção</string>
    <string name="q147">As memórias de semicondutores são consideradas aquelas que utilizam composição de ___________ como forma principal de armazenamento. Dentro deste grupo estão os registradores, memórias cache, memórias principais e, mais recentemente, cartões de memória, pen-drives e os chamados ___________, que não possuem formatos de disco, mas receberam esse nome por serem os candidatos mais cotados a substituírem os ___________.</string>
    <string name="q147a">A)válvulas; Discos de Estado Sólido (SSD); Discos Rígidos (HD)</string>
    <string name="q147b">B)transistores; Discos de Estado Líquido (SSL); Discos Flexíveis (HF)</string>
    <string name="q147c">C)válvulas; Discos de Estado Líquido (SSL); Discos Rígidos (HD)</string>
    <string name="q147d">D)transistores; Discos de Estado Sólido (SSD); Fitas magnéticas</string>
    <string name="q147e">E)transistores; Discos de Estado Sólido (SSD); Discos Rígidos (HD)</string>
    <string name="q148">Dentro das memórias de semicondutores temos: \n1. Random-Access Memory (RAM) \n2. Dynamic RAM (DRAM) \n3. Static RAM (SRAM) \n4. Synchronous Dynamic RAM (SDRAM) \n5. Double-Data Rate SDRAM (DDR-DRAM) \n6. Read-Only Memory (ROM)</string>
    <string name="q148a">A)1 e 2</string>
    <string name="q148b">B)2 e 3</string>
    <string name="q148c">C)3 e 4</string>
    <string name="q148d">D)4, 5 e 6</string>
    <string name="q148e">E)Todas as alternativas</string>
    <string name="q149">O termo Random-Access Memory, ou RAM, ou Memória de Acesso Aleatório em português, veio porque essa tecnologia substituiu as anteriores. No ___________, os endereços são acessados obrigatoriamente de forma ___________ Essa é a forma de acesso de memórias magnéticas, como ___________, e os ___________ (com alguma melhoria). Já as memórias de acesso aleatório podem acessar qualquer endereço aleatoriamente, independente de sua posição.</string>
    <string name="q149a">A)Acesso Sequencial; sequencial, 0, 1, 2, 3,...; ﬁtas cassete e VHS; discos rígidos</string>
    <string name="q149b">B)Acesso Sequencial; aleatório; ﬁtas cassete e VHS; discos rígidos</string>
    <string name="q149c">C)Acesso Sequencial; sequencial, 0, 1, 2, 3,...; ﬁtas cassete e VHS; SSD</string>
    <string name="q149d">D)Acesso Aleatório; aleatório; ﬁtas cassete e VHS; discos rígidos</string>
    <string name="q149e">E)Acesso Aleatório; sequencial, 10, 20, 30, 40,...; ﬁtas cassete e VHS; discos rígidos</string>
    <string name="q150">Hoje, o termo Memória RAM é utilizado de forma errada para representar ___________, mas na verdade, tanto registradores, quanto memória Cache e Memória Principal são feitos utilizando tecnologia RAM. Assim, RAM é uma ___________. A partir de hoje então, não utilize mais memória RAM, mas Memória Principal quando se referir à principal memória dos computadores.</string>
    <string name="q150a">A)a Memória Principal; memória e não uma tecnologia </string>
    <string name="q150b">B)a Memória Cache; memória e não uma tecnologia </string>
    <string name="q150c">C)a Memória Principal; tecnologia e não uma memória </string>
    <string name="q150d">D)a Memória Cache; tecnologia e não uma memória </string>
    <string name="q150e">E)o disco rígido (HD); tecnologia e não uma memória</string>
    <string name="q151">As memórias ___________ são as mais simples de serem fabricadas. É formada simplesmente por um único transistor e um capacitor. O transistor cuida de abrir ou fechar a passagem de corrente para linha B. Já a linha de endereço é utilizada para fechar a porta do transistor e carregar o capacitor. Se o capacitor estiver carregado, é considerado que a memória contém o bit 1. Caso contrário, a memória contém o bit 0. A simplicidade desta implementação traz resultado no seu principal ponto negativo. Assim como todo capacitor, o capacitor responsável por manter a carga da memória só é capaz de manter a carga por um curto tempo. Aos poucos, a carga vai sendo dissipada, até o momento em que era o bit 1, se torna 0, gerando um erro. Para evitar isso, é adicionado um circuito a parte que lê o conteúdo da memória periodicamente e recarrega todos capacitores que estão com bit 1. Vamos lembrar que as memórias hoje estão na casa de Giga Bytes. Ou seja, bilhões de bytes. Então, bilhões de capacitores devem ser lidos e recarregados periodicamente para que os conteúdos não sejam perdidos. Esta técnica é chamada de Refrescagem. Ela resolve o problema dos dados perdidos, mas atrapalha bastante o desempenho da memória. Sempre que a Refrescagem precisa ser realizada, todo acesso é bloqueado. Nada pode ser lido ou escrito enquanto isso. Assim, o processador precisa esperar que o processo de refrescarem termine para poder acessar novamente a memória. Devido à sua simplicidade de fabricação, essas memórias são mais utilizadas para compor a Memória Principal, devido ao preço mais acessível do que o das outras.</string>
    <string name="q151a">A)ROM</string>
    <string name="q151b">B)Dynamic RAM (DRAM)</string>
    <string name="q151c">C)Synchronous Dynamic RAM (SDRAM)</string>
    <string name="q151d">D)RAM Estáticas (Static RAM ou SRAM)</string>
    <string name="q151e">E)DDR-SDRAM</string>
    <string name="q152">As memórias ___________ se baseiam na composição de transistores para possibilitar que a carga do bit 1 seja compartilhada entre outros transistores. Numa ilustração simples, uma estrutura dessa memória pode conter seis transitores, um determina se o bit é 0 ou 1, outros dois são utilizados para recarregá-los, caso sua carga reduza. Os três restantes são o complemento deles de forma inversa, adicionando um nível a mais de segurança. Essa técnica é chamada Complementary MOS(CMOS). Essa memória não precisam de circuito de refrescarem, por isso, não precisam parar e tornam-se muito mais rápidas do que as outras. O problema é que elas precisam de muito mais transistores por bit, o que torna o projeto maior e, por consequência, mais caro. Devido ao seu preço, elas são mais utilizadas em memórias Cache, mas em menor quantidade do que as memórias principais.</string>
    <string name="q152a">A)ROM</string>
    <string name="q152b">B)Dynamic RAM (DRAM)</string>
    <string name="q152c">C)Synchronous Dynamic RAM (SDRAM)</string>
    <string name="q152d">D)RAM Estáticas (Static RAM ou SRAM)</string>
    <string name="q152e">E)DDR-SDRAM</string>
    <string name="q153">A ___________ é uma RAM com um simples avanço. O relógio que determina o tempo desta memória vem diretamente do processador, e não de um relógio próprio, como nas convencionais. Isso faz com que o momento exato da Refrescagem seja determinado pelo processador. Dessa forma, o processador sabe exatamente quando ele não pode acessar a memória, e dedica seu tempo às outras tarefas, ou seja, o processador não perde mais tanto tempo esperando a memória.</string>
    <string name="q153a">A)ROM</string>
    <string name="q153b">B)Dynamic RAM (DRAM)</string>
    <string name="q153c">C)Synchronous Dynamic RAM (SDRAM)</string>
    <string name="q153d">D)RAM Estáticas (Static RAM ou SRAM)</string>
    <string name="q153e">E)DDR-SDRAM</string>
    <string name="q154">Essa memória surgiu após as SDRAM. Essas memórias são síncronas como as SDRAM, mas elas possuem um barramento extra que faz com que, a cada ciclo de clock da memória, o dobro de dados são transferidos. Essas memórias e suas sucessoras são mais utilizadas para utilização como memória principal.</string>
    <string name="q154a">A)ROM</string>
    <string name="q154b">B)Dynamic RAM (DRAM)</string>
    <string name="q154c">C)Synchronous Dynamic RAM (SDRAM)</string>
    <string name="q154d">D)RAM Estáticas (Static RAM ou SRAM)</string>
    <string name="q154e">E)DDR-SDRAM</string>
    <string name="q155">Essas memórias possuem um nome criado há muitos anos e hoje é um termo que não faz tanto sentido. Em português signiﬁcam Memória Apenas de Leitura. Isso porque as primeiras eram escritas durante a fabricação e não podiam mais ser modiﬁcadas. Mas outras gerações foram desenvolvidas que permitiram a escrita e tornou esse termo antiquado. Todas memórias desse tipo são não voláteis, ou seja, mantêm seu conteúdo mesmo com a falta do fornecimento de energia elétrica.</string>
    <string name="q155a">A)ROM</string>
    <string name="q155b">B)Dynamic RAM (DRAM)</string>
    <string name="q155c">C)Synchronous Dynamic RAM (SDRAM)</string>
    <string name="q155d">D)RAM Estáticas (Static RAM ou SRAM)</string>
    <string name="q155e">E)DDR-SDRAM</string>
    <string name="q156">São tipos de memória ROM: \n1. EPROM (Erasable PROM), \n2. EEPROM (Electronically Erasable PROM), \n3. memórias Flash, \n4. PROM (Programmable ROM)</string>
    <string name="q156a">A)1 e 2</string>
    <string name="q156b">B)1 e 3</string>
    <string name="q156c">C)1, 2 e 3</string>
    <string name="q156d">D)2, 3 e 4 </string>
    <string name="q156e">E)1, 2, 3 e 4</string>
    <string name="q157">___________ são memórias que vem com a conexões abertas de fábrica e precisam de uma máquina para que os dados sejam escritos nelas. Uma vez escritos, eles não podem mais ser modiﬁcados.</string>
    <string name="q157a">A)memórias EEPROM (Electronically Erasable PROM)</string>
    <string name="q157b">B)PROM (Programmable ROM)</string>
    <string name="q157c">C)memórias EPROM (Erasable PROM)</string>
    <string name="q157d">D)memória ROM</string>
    <string name="q157e">E)memórias Flash</string>
    <string name="q158">As ___________ podem ser reescritas, mas uma máquina especial que utiliza raios UV pode ser utilizada para apagar todo seu conteúdo e escrever novamente.</string>
    <string name="q158a">A)memórias Flash</string>
    <string name="q158b">B)memória ROM</string>
    <string name="q158c">C)memórias EEPROM (Electronically Erasable PROM)</string>
    <string name="q158d">D)PROM (Programmable ROM)</string>
    <string name="q158e">E)memórias EPROM (Erasable PROM)</string>
    <string name="q159">As ___________ podem ser reescritas, mas a máquina utilizada para escrita e apagar é eletrônica. Isso permite que um computador, ou um máquina especial seja utilizada para escrever nas memórias, as tornando muito mais utilizadas.</string>
    <string name="q159a">A)PROM (Programmable ROM)</string>
    <string name="q159b">B)memórias Flash</string>
    <string name="q159c">C)memórias EEPROM (Electronically Erasable PROM)</string>
    <string name="q159d">D)memórias EPROM (Erasable PROM)</string>
    <string name="q159e">E)memória ROM</string>
    <string name="q160">As ___________ podem ser reescritas, mas o processo de apagar é feito em blocos grandes, o que acelera bastante o processo.</string>
    <string name="q160a">A)memórias Flash</string>
    <string name="q160b">B)PROM (Programmable ROM)</string>
    <string name="q160c">C)memórias EPROM (Erasable PROM)</string>
    <string name="q160d">D)memórias EEPROM (Electronically Erasable PROM)</string>
    <string name="q160e">E)memória ROM</string>
    <string name="q161"> As ___________ são muito utilizadas na formação da BIOS dos computadores e as ___________ são o princípio básico de cartões de memória, pen-drives e memórias de estado sólido.</string>
    <string name="q161a">A)memórias ROM; memórias Flash</string>
    <string name="q161b">B)memórias RAM; memórias PROM</string>
    <string name="q161c">C)memórias Cache; memórias EEPROM</string>
    <string name="q161d">D)memórias ROM; memórias EPROM</string>
    <string name="q161e">E)memórias RAM; memórias Flash</string>
    <string name="q162">Quais das memórias abaixo são chamadas de Memórias Primárias, porque são usadas para o funcionamento básico e primário da CPU?\n1. Flash \n2. ROM \n3. PROM \n4. EEPROM \n5. EPROM \n6. DDR-SDRAM \n7. SDRAM \n8. SRAM \n9. DRAM</string>
    <string name="q162a">A)1, 2, 3 e 5</string>
    <string name="q162b">B)1, 2, 4 e 6</string>
    <string name="q162c">C)1, 2, 3, 6 e 7</string>
    <string name="q162d">D)1, 2, 3, 5, 8, 9</string>
    <string name="q162e">E)Todas memórias</string>
    <string name="q163">As memórias secundárias são utilizadas para dar um suporte a mais ao sistema, ampliando sua capacidade de armazenamento. O objetivo destas memórias é o de trazer mais capacidade, sem o intuito de realizar operações muito velozes. São as principais tecnologias utilizadas como memórias secundárias: \n1. Memórias magnéticas \n2. Memórias ópticas \n3. Memórias de estado Líquido </string>
    <string name="q163a">A)1</string>
    <string name="q163b">B)1 e 2</string>
    <string name="q163c">C)1 e 3</string>
    <string name="q163d">D)2 e 3</string>
    <string name="q163e">E)1, 2 e 3</string>
    <string name="q164">___________ utilizam o princípio de polarização para identiﬁcar dados numa superfície magnetizável. Assim como num imã, cada minúscula área da memória é magnetizada como sendo polo positivo ou negativo (ou Norte e Sul). Quando a região é polarizada com polo positivo, dizemos que ela armazena o bit 1, e armazena o bit 0, quando a polarização for negativa. O maior exemplo de memória magnética utilizado hoje são os Discos Rígidos, ou do inglês Hard Disk (ou HD).</string>
    <string name="q164a">A)Memórias ópticas</string>
    <string name="q164b">B)Memória RAM</string>
    <string name="q164c">C)Memórias magnéticas</string>
    <string name="q164d">D)Memória ROM</string>
    <string name="q164e">E)Memórias de estado sólido (ou em inglês Solid State Disk - SSD)</string>
    <string name="q165">___________: Armazenam seus dados numa superfície reﬂexiva. Para leitura, um feixe de luz (LASER) é disparado contra um também minúsculo ponto. O feixe bate na superfície volta para um sensor. Isso indicará que naquele ponto há o bit 0. Para armazenar o bit 1, um outro LASER entra em ação provocando um pequena baixa na região. Com isso, ao fazer uma leitura no mesmo ponto, o feixe de luz ao bater na superfície com a baixa será reﬂetido mas tomará trajetória diferente, atingindo um outro sensor diferente daquele que indicou o bit 0. Quando este segundo sensor detecta o feixe de luz, é dito que o bit lido foi o 1. O maior representante das memórias ópticas são os CDs, DVDs e, mais recentemente os Blu-Ray.</string>
    <string name="q165a">A)Memórias ópticas</string>
    <string name="q165b">B)Memória RAM</string>
    <string name="q165c">C)Memórias magnéticas</string>
    <string name="q165d">D)Memória ROM</string>
    <string name="q165e">E)Memórias de estado sólido (ou em inglês Solid State Disk - SSD)</string>
    <string name="q166">___________ São memórias feitas com tecnologia Flash mas para ser usadas em substituição ao Disco Rígido. Em comparação com ele, a memória de estado sólido é muito mais rápida, mais residente a choques e consome menos energia. Em contrapartida, as memórias de estado sólido são bem mais caras.</string>
    <string name="q166a">A)Memórias ópticas</string>
    <string name="q166b">B)Memória RAM</string>
    <string name="q166c">C)Memórias magnéticas</string>
    <string name="q166d">D)Memória ROM</string>
    <string name="q166e">E)Memórias de estado sólido (ou em inglês Solid State Disk - SSD)</string>
    <string name="q167">___________ é a técnica de utilizar a Memória Secundária, geralmente HD ou SSD, como uma extensão da Memória Principal. Desta forma, quando a memória principal está cheia e não há mais espaço para novos programas ou dados, o sistema utiliza a memória secundária. Tudo é feito de forma automática pela ___________ presente nos processadores. Assim, todo dado que é acessado é antes buscado pela MMU na memória principal. Se ele não estiver lá, ela vai buscar na memória secundária, faz uma cópia na memória principal e libera o acesso ao dado.</string>
    <string name="q167a">A)Memória Virtual; Unidade de Marketing de Memória (ou Memory Market Unit - MMU)</string>
    <string name="q167b">B)Memória Virtual; Unidade Magnética de Memória (ou Memory Magnetic Unit - MMU)</string>
    <string name="q167c">C)Memória Virtual; Unidade de Gerência de Memória (ou Memory Management Unit - MMU)</string>
    <string name="q167d">D)Memória Cache; Unidade Magnética de Memória (ou Memory Magnetic Unit - MMU)</string>
    <string name="q167e">E)Memória Cache; Unidade de Gerência de Memória (ou Memory Management Unit - MMU)</string>
    <string name="q168">A principal técnica de Memória Virtual é a ___________.</string>
    <string name="q168a">A)refrescagem</string>
    <string name="q168b">B)Paginação</string>
    <string name="q168c">C)raid</string>
    <string name="q168d">D)arquivação</string>
    <string name="q168e">E)raid 0</string>
    <string name="q169">Na ___________, todos os dados são acessados através de páginas. Isso facilita o processo de organização e localização dos dados que estão na memória principal e secundária. Agora, ao invés de gerenciar palavra por palavra, o sistema gerencia grandes blocos (geralmente de 64KB) chamados de páginas.</string>
    <string name="q169a">A)refrescagem</string>
    <string name="q169b">B)Paginação</string>
    <string name="q169c">C)raid</string>
    <string name="q169d">D)arquivação</string>
    <string name="q169e">E)raid 0</string>
    <string name="q170">As ___________ vem tendo um papel cada vez mais importante nos sistemas computacionais. Inicialmente elas nem existiam nos computadores. Depois foram adicionadas fora do processador e em pequena quantidade. Em seguida elas foram levadas para dentro do processador e hoje em dia ocupam entre 60 por cento e 80 por cento da área do chip do processador. O princípio básico desta memória é o de manter uma cópia dos dados e instruções mais utilizados recentemente (Princípio da Localidade) para que os mesmos não precisem ser buscados na memória principal. Como elas são muito mais rápidas do que a memória principal, isso traz um alto ganho de desempenho.</string>
    <string name="q170a">A)memórias Cache</string>
    <string name="q170b">B)registradores</string>
    <string name="q170c">C)ULA</string>
    <string name="q170d">D)PC</string>
    <string name="q170e">E)MBR</string>
    <string name="q171">Todo dado a ser lido ou escrito em memória pelo processador antes passa para a ___________. Se o dado estiver, a operação é feita nela e não se precisa ir até a ___________. Caso contrário, um bloco inteiro de dados (geralmente com 4 palavras de memória) é trazido. Só então a CPU realiza a tarefa com o dado. Sendo assim, o desempenho do computador ao acessar um dado de memória é probabilístico.</string>
    <string name="q171a">A)Cache; Memória Virtual</string>
    <string name="q171b">B)Virtual; Memória Principal </string>
    <string name="q171c">C)Cache; Memória Principal</string>
    <string name="q171d">D)registrador; Memória Secundária</string>
    <string name="q171e">E)Cache; Memória Secundária</string>
    <string name="q172">Para cada dado a ser acessado há uma probabilidade dele estar na ___________. Se isso ocorrer dizemos que houve um ___________ e o sistema ganha muito tempo com isso. Caso contrário, ocorre uma ___________ e o desempenho é bastante prejudicado.</string>
    <string name="q172a">A)memória rom; Cache Hit; Cache Miss</string>
    <string name="q172b">B)memória ram; Cache Miss; Cache Hit</string>
    <string name="q172c">C)memória virtual; Cache Hit; Cache Miss</string>
    <string name="q172d">D)memória Cache; Cache Miss; Cache Hit</string>
    <string name="q172e">E)memória Cache; Cache Hit; Cache Miss</string>
    <string name="q173">A grande questão é, como fazemos para aumentar a probabilidade de um determinado dado estar na memória Cache ao invés da Memória Principal? Podemos também refazer esta pergunta de uma forma mais geral. Como aumentar a taxa de Cache Hit (ou diminuir a taxa de Cache Miss)? Há três principais estratégias para isso. São elas: \n1. Diminuir o tamanho da Memória Cache \n2. Mudar a função de mapeamento \n3. Mudar a política de substituição </string>
    <string name="q173a">A)1</string>
    <string name="q173b">B)3</string>
    <string name="q173c">C)1 e 2</string>
    <string name="q173d">D)2 e 3</string>
    <string name="q173e">E)1, 2 e 3</string>
    <string name="q174">A grande diﬁculdade das memórias Cache é que elas sempre estão presentes em menor quantidade do que a Memória Principal. Geralmente a Memória Cache de um computador é 1.000 vezes menor do que a Memória Principal. Se você tem um computador com 4GB de Memória Principal (não usa mais RAM para indicar este tipo de memória!), você terá muita sorte se seu processador tiver 4MB de Memória Cache. Como a Memória Cache trabalha armazenando cópias de dados da Memória Principal, quanto maior for a Memória Cache, mais dados ela é capaz de armazenar, sendo assim, maior a probabilidade do processador buscar por um dado e ele estar na Cache. Entretanto, é importante observar que esse crescimento não é constante. ___________.</string>
    <string name="q174a">A)O ganho de desempenho com a diminuição do tamanho da Cache possui um limite</string>
    <string name="q174b">B)O ganho de desempenho com o aumento do tamanho da Cache não possui um limite</string>
    <string name="q174c">C)O ganho de desempenho com o diminuição do tamanho da Cache não possui um limite</string>
    <string name="q174d">D)O ganho de desempenho com o aumento do tamanho da Cache sempre será ilimitado</string>
    <string name="q174e">E)O ganho de desempenho com o aumento do tamanho da Cache possui um limite</string>
    <string name="q175">A função de mapeamento diz respeito a estratégia utilizada para determinar onde cada dado da memória principal estará na Cache. Ela determina onde cada dado da Memória Principal será copiado na Cache caso ele seja acessado. Isso é muito importante porque o processador vai seguir essa mesma estratégia para conseguir localizar se o dado está, ou não na Cache. Há três tipos de mapeamento: \n1. Mapeamento indireto \n2. Mapeamento associativo \n3. Mapeamento associativo por conjunto</string>
    <string name="q175a">A)2</string>
    <string name="q175b">B)1 e 2</string>
    <string name="q175c">C)1 e 3</string>
    <string name="q175d">D)2 e 3</string>
    <string name="q175e">E)1, 2 e 3</string>
    <string name="q176">Para entendermos ___________, vamos fazer uma analogia com uma sala de cinema. Imagine que o cinema é a Memória Cache e cada pessoa é um dado a ser armazenado na memória. Neste mapeamento cada pessoa (sócia daquele cinema) receberá uma cadeira dedicada a ele. Sempre que ele for ao cinema, deverá sentar no mesmo lugar. O problema é que a Memória Principal é muito maior do que a Memória Cache, então não há cadeira para todos. Para resolver, cada cadeira é distribuída por várias pessoas, apostando que nem sempre as pessoas que compartilham o mesmo número de cadeira irão assistir ao mesmo ﬁlme no mesmo horário. Mas quando isso acontece, a pessoa que chegou por último não pode sentar em outra cadeira mesmo estando livre. A pessoa que chega depois toma o lugar da pessoa que está sentada, porque no caso da memória Cache, o último sempre tem preferência. Imagine quanta confusão isso geraria nesse cinema! O bom deste mapeamento é porque ele é muito fácil de organizar e a CPU encontra sempre seu dado muito facilmente. No exemplo do cinema, se alguém estiver querendo saber se uma pessoa está no cinema (na Cache) ou não (na Memória Principal) basta saber o número da cadeira dele e ir lá veriﬁcar se é ele quem está sentado. Isso acelera bastante o trabalho de busca da CPU. Mas se a memória Cache for muito menor que a Memória Principal, haverá muitos blocos com mesmo código e pode haver muito conﬂito de posição, reduzindo o desempenho. Por exemplo, imagine uma Cache que armazena apenas 5 linhas (é o termo utilizado no local onde um bloco da Memória Principal é salvo na Cache), com numeração de 1 a 5. A Memória Principal será mapeada da seguinte forma, o bloco 1 será salvo na linha 1 da Cache, o bloco 2 na linha 2 etc. até o bloco 5 que será salvo na linha 5. Já o bloco 6 da memória será salvo novamente na linha 1 da Cache, o bloco 7 na linha 2, bloco 8 na linha 3 etc. Isso será feito até o que todos blocos da Memória Principal tenham uma linha a ser armazenada. </string>
    <string name="q176a">A)o mapeamento direto</string>
    <string name="q176b">B)o mapeamento associativo</string>
    <string name="q176c">C)o mapeamento associativo por conjunto</string>
    <string name="q176d">D)o mapeamento indireto</string>
    <string name="q176e">E)o mapeamento não associativo</string>
    <string name="q177">Suponha que os seguintes blocos da Memória Principal sejam acessados em sequência: 1, 5, 1, 10, 11, 5. Como será o mapeamento e quando ocorrerá Cache Hit e Cache Miss? No início o bloco 1 é acessado mas ele não está na Cache, ocorre um Cache Miss e a cópia é salva. Então temos: \nCache hit: 0 \nCache miss: 1 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 - - - - \nEm seguida o bloco 5 é acessado. Ele não está na Cache, ocorre um Cache miss e uma cópia é salva na posição 5. Temos então: \nCache hit: 0 \nCache miss: 2 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 - - - 5 \nNo terceiro acesso, o bloco 1 é buscado. Ele já consta na Cache. Então ocorre um cache hit e a cache não precisa ser alterada. Ficando assim: \nCache hit: 1 \nCache miss: 2 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 - - - 5 \nAo acessar em seguida o bloco 10 é acessado, como ele deve ocupar mesma posição do bloco 5 (isso porque 10 - 5 = 10), há um cache miss, o 5 é removido e substituído pelo 10. \nCache hit: 1 \nCache miss: 3 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 - - - 10 \nNo próximo acesso o bloco 11 é buscado na posição 1 porque 11 - 5 = 6 e 6 - 5 = 1. Ele não é encontrado, mas sim o bloco 1. Há um cache miss e o bloco 1 é substituído pelo 11, resultado no seguinte: \nCache hit: 1 \nCache miss: 4 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 11 - - - 10 \nPor último, o bloco 5 é buscado novamente, mas o bloco 10 é quem ocupa esta posição. Há um cache miss e o bloco 10 é substituído pelo 5. Como resultado ﬁnal, temos: \nCache hit: 1 \nCache miss: 5 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 11 - - - 5. Esse exemplo trata-se do mapeamento: </string>
    <string name="q177a">A)o mapeamento direto</string>
    <string name="q177b">B)o mapeamento associativo</string>
    <string name="q177c">C)o mapeamento associativo por conjunto</string>
    <string name="q177d">D)o mapeamento indireto</string>
    <string name="q177e">E)o mapeamento não associativo</string>
    <string name="q178">No ___________, o mecanismo de alocação de blocos da Memória Principal na Cache não segue posição ﬁxa. Cada bloco vai ocupar a primeira posição vazia encontrada. Utilizando um cinema como exemplo de memória Cache, seria uma sala sem cadeira reservada, mas com um porém. Se uma pessoa chegar e o cinema estiver cheio, a direção do cinema (no computador é o Sistema de Memória) vai escolher uma pessoa a ser removida para dar lugar a nova pessoa que chegou (talvez alguém que estiver dormindo ou conversando durante o ﬁlme).</string>
    <string name="q178a">A)o mapeamento direto</string>
    <string name="q178b">B)o mapeamento associativo</string>
    <string name="q178c">C)o mapeamento associativo por conjunto</string>
    <string name="q178d">D)o mapeamento indireto</string>
    <string name="q178e">E)o mapeamento não associativo</string>
    <string name="q179">O ___________ termina sendo mais eﬁciente do que o ___________ no momento de alocar blocos da memória na Cache. Só haverá espaço inutilizado se não houver acesso suﬁciente à Memória Principal. A desvantagem deste tipo de mapeamento está no momento de buscar um bloco na Cache. Utilizando um cinema como exemplo de memória Cache, imagine agora que alguém chegue no cinema cheio a procura de uma pessoa. Como encontrá-la? Será necessário percorrer todas cadeiras para veriﬁcar se a pessoa se encontra em alguma delas. Para o sistema computacional, essa busca é custosa o que resulta na utilização deste mapeamento apenas se a Cache não for grande demais.</string>
    <string name="q179a">A)mapeamento associativo; mapeamento indireto</string>
    <string name="q179b">B)mapeamento associativo; mapeamento direto</string>
    <string name="q179c">C)mapeamento associativo; mapeamento associativo por conjunto</string>
    <string name="q179d">D)mapeamento direto; mapeamento associativo por conjunto</string>
    <string name="q179e">E)mapeamento direto; mapeamento indireto</string>
    <string name="q180">Vamos supor um exemplo de acesso à uma memória Cache de 5 linhas para a sequência de acesso: 1, 5, 1, 10, 11, 5. No início o bloco 1 é acessado mas ele não está na Cache, ocorre um Cache Miss e a cópia é salva. Sempre há cache miss nos primeiros acessos de um programa e eles são impossíveis de serem evitados. Então temos: \nCache hit: 0 \nCache miss: 1 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 - - - - \nEm seguida o bloco 5 é acessado e há novamente um cache miss, mas dessa vez vamos adicioná-lo na primeira posição livre que encontrarmos. Neste caso, na posição 2. Temos então: \nCache hit: 0 \nCache miss: 2 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 5 - - - \nNo próximo acesso ao bloco 1 há um cache hit porque o bloco 1 é acessado e ele já está presente na Cache: \nCache hit: 1 \nCache miss: 2 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 5 - - - \nEm seguida o bloco 10 é acessado. Ele não está na Cache e ocorre um Cache Miss e ele é salvo na posição 3. \nCache hit: 1 \nCache miss: 3 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 5 10 - - \nNo próximo passo o bloco 11 é acessado. Ele também não está na Cache e é salvo na posição 4. \nCache hit: 1 \nCache miss: 4 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 5 10 11 - \nNo último acesso o bloco 5 é acusado novamente. Como ele está na Cache, há um cache hit e a cache não é modiﬁcada. \nCache hit: 2 \nCache miss: 4 \nPosição da Cache: 1 2 3 4 5 \nLinhas na Cache: 1 5 10 11 - \nEsse mapeamento foi mais eﬁciente para esse exemplo, já que precisou ir menos à Memória Principal mais lenta para trazer os blocos. Note também que a memória Cache permanece mais utilizada quando esse mapeamento é aplicado. Isso aumenta bastante a probabilidade novos cache hit.</string>
    <string name="q180a">A)o mapeamento direto</string>
    <string name="q180b">B)o mapeamento associativo</string>
    <string name="q180c">C)o mapeamento associativo por conjunto</string>
    <string name="q180d">D)o mapeamento indireto</string>
    <string name="q180e">E)o mapeamento não associativo</string>
    <string name="q181">O problema do Mapeamento Associativo é encontrar blocos em memórias Cache grandes. A solução para isso é utilizar uma abordagem mista, que utiliza os princípios dos mapeamentos direto e associativo. Ela divide a memória em conjuntos. Cada bloco então é mapeado para um conjunto (semelhante ao que é feito para o Mapeamento Direto, mas para o nível de conjunto). Sempre que um bloco for ser buscado ou salvo, ele será feito no conjunto ﬁxo dele, mas dentro do conjunto ele pode ser armazenado em qualquer posição livre. Utilizando um cinema como exemplo de memória Cache, é como se uma grande sala fosse dividida em salas menores. Cada pessoa teria no seu ingresso o número da sala, mas a poltrona seria escolhida livremente. Escolhendo a quantidade certa e o tamanho das salas, é possível utilizar bem os espaços e facilitar o processo de busca por uma pessoa.</string>
    <string name="q181a">A)o mapeamento direto</string>
    <string name="q181b">B)o mapeamento associativo</string>
    <string name="q181c">C)o mapeamento associativo por conjunto</string>
    <string name="q181d">D)o mapeamento indireto</string>
    <string name="q181e">E)o mapeamento não associativo</string>
    <string name="q182">Nos mapeamentos associativo e associativo por conjunto uma outra política deve ser adotada. Quando a memória cache enche e um novo bloco precisa ser armazenado, o Sistema de Memória deve escolher que bloco deve ser removido para dar espaço ao novo bloco. No mapeamento direto isso não existe porque cada bloco sempre ﬁca na mesma posição. Sendo assim, há 3 principais políticas de substituição de linhas de Cache. São elas: \n1. Randômica \n2. FIFO \n3. LRU \n4. LILO</string>
    <string name="q182a">A)1 e 2</string>
    <string name="q182b">B)1 e 3</string>
    <string name="q182c">C)1, 2 e 3</string>
    <string name="q182d">D)2, 3 e 4</string>
    <string name="q182e">E)1, 2, 3 e 4</string>
    <string name="q183">Na substituição ___________ o sistema simplesmente escolhe aleatoriamente o bloco que deve ser removido. Ele sai da Cache dando lugar ao novo bloco que foi acessado. Este método tem a vantagem de ser muito fácil de implementar e, por consequência, rápido de executar. Porém ele pode não ser muito eﬁciente.</string>
    <string name="q183a">A)randômica</string>
    <string name="q183b">B)FIFO (First-In First-Out)</string>
    <string name="q183c">C)LILO (Last-in Last-Out)</string>
    <string name="q183d">D)LRU (Least-Recently Used), ou “Menos Usado Recentemente”</string>
    <string name="q183e">E)matemática</string>
    <string name="q184">Na substituição ___________ adota o princípio de ﬁla. Aquele bloco que chegou primeiro, está há mais tempo na Cache. Já se beneﬁciou bastante e deve então dar lugar ao novo bloco.</string>
    <string name="q184a">A)randômica</string>
    <string name="q184b">B)FIFO (First-In First-Out)</string>
    <string name="q184c">C)LILO (Last-in Last-Out)</string>
    <string name="q184d">D)LRU (Least-Recently Used), ou “Menos Usado Recentemente”</string>
    <string name="q184e">E)matemática</string>
    <string name="q185">Na substituição ___________ aplica o Princípio da Localidade Temporal e torna-se por isso mais eﬁciente na maioria dos casos. Nesta política o sistema escolhe o bloco que menos foi utilizado recentemente e o remove. Isso faz com que ﬁquem na Cache aqueles blocos que são acessados mais vezes nos últimos instantes.</string>
    <string name="q185a">A)randômica</string>
    <string name="q185b">B)FIFO (First-In First-Out)</string>
    <string name="q185c">C)LILO (Last-in Last-Out)</string>
    <string name="q185d">D)LRU (Least-Recently Used), ou “Menos Usado Recentemente”</string>
    <string name="q185e">E)matemática</string>
    <string name="q186">Computador de Conjunto de Instruções Complexo.</string>
    <string name="q186a">A)PC (Program Counter) </string>
    <string name="q186b">B)CISC(Complex Instruction Set Computer) </string>
    <string name="q186c">C)ISA (Instruction Set Architecture) </string>
    <string name="q186d">D)IR (Instruction Register) </string>
    <string name="q186e">E)MAR (Memory Address Register) </string>
    <string name="q187">Contador de Programas.</string>
    <string name="q187a">A)PC (Program Counter) </string>
    <string name="q187b">B)CISC(Complex Instruction Set Computer) </string>
    <string name="q187c">C)ISA (Instruction Set Architecture) </string>
    <string name="q187d">D)IR (Instruction Register) </string>
    <string name="q187e">E)MAR (Memory Address Register) </string>
    <string name="q188">Registrador de Instrução.</string>
    <string name="q188a">A)PC (Program Counter) </string>
    <string name="q188b">B)CISC(Complex Instruction Set Computer) </string>
    <string name="q188c">C)ISA (Instruction Set Architecture) </string>
    <string name="q188d">D)IR (Instruction Register) </string>
    <string name="q188e">E)MAR (Memory Address Register) </string>
    <string name="q189">O Conjunto de Instruções é a interface entre os softwares que serão executados pelo proces- sador e o próprio processador.</string>
    <string name="q189a">A)PC (Program Counter) </string>
    <string name="q189b">B)CISC(Complex Instruction Set Computer) </string>
    <string name="q189c">C)ISA (Instruction Set Architecture) </string>
    <string name="q189d">D)IR (Instruction Register) </string>
    <string name="q189e">E)MAR (Memory Address Register) </string>
    <string name="q190">Registrador de Endereço.</string>
    <string name="q190a">A)PC (Program Counter) </string>
    <string name="q190b">B)CISC(Complex Instruction Set Computer) </string>
    <string name="q190c">C)ISA (Instruction Set Architecture) </string>
    <string name="q190d">D)IR (Instruction Register) </string>
    <string name="q190e">E)MAR (Memory Address Register) </string>
    <string name="q191">Registrador de Dados.</string>
    <string name="q191a">A)ULA </string>
    <string name="q191b">B)MAR (Memory Address Register) </string>
    <string name="q191c">C)MBR (Memory Buffer Register)</string>
    <string name="q191d">D)PC (Program Counter) </string>
    <string name="q191e">E)UC </string>
    <string name="q192">Unidade Lógica e Aritmética.</string>
    <string name="q192a">A)ULA </string>
    <string name="q192b">B)MAR (Memory Address Register) </string>
    <string name="q192c">C)MBR (Memory Buffer Register)</string>
    <string name="q192d">D)PC (Program Counter) </string>
    <string name="q192e">E)UC</string>
    <string name="q193">Unidade de Controle.</string>
    <string name="q193a">A)ULA </string>
    <string name="q193b">B)MAR (Memory Address Register) </string>
    <string name="q193c">C)MBR (Memory Buffer Register)</string>
    <string name="q193d">D)PC (Program Counter) </string>
    <string name="q193e">E)UC</string>
    <string name="q194">Ciclo carregar instrução. Traz a instrução da memória para o processador, armazena em [IR] [71] (essa etapa também é chamada de Fetch de Instrução) e a decodiﬁca para execução no passo seguinte.</string>
    <string name="q194a">A)WR (Write to register) </string>
    <string name="q194b">B)FO (Fetch operands)</string>
    <string name="q194c">C)FI (Fetch Instruction)</string>
    <string name="q194d">D)EI (Execute Instructions) </string>
    <string name="q194e">E)WM (Write to memory)</string>
    <string name="q195">Clico carregar operandos. Traz os operandos da operação dos registradores para a ULA, para que a operação seja realizada sobre eles, também chamada de Fetch de Operandos.</string>
    <string name="q195a">A)WR (Write to register) </string>
    <string name="q195b">B)FO (Fetch operands)</string>
    <string name="q195c">C)FI (Fetch Instruction)</string>
    <string name="q195d">D)EI (Execute Instructions) </string>
    <string name="q195e">E)WM (Write to memory)</string>
    <string name="q196">Ciclo executar instruções. Executa operação lógica ou aritmética propriamente dita.</string>
    <string name="q196a">A)WR (Write to register) </string>
    <string name="q196b">B)FO (Fetch operands)</string>
    <string name="q196c">C)FI (Fetch Instruction)</string>
    <string name="q196d">D)EI (Execute Instructions) </string>
    <string name="q196e">E)WM (Write to memory)</string>
    <string name="q197">Computador de Conjunto de Instruções Reduzido.</string>
    <string name="q197a">A)TOS (Top of Stack) </string>
    <string name="q197b">B)CISC(Complex Instruction Set Computer)</string>
    <string name="q197c">C)RISC (Reduced Instruction Set Computer) </string>
    <string name="q197d">D)MBR </string>
    <string name="q197e">E)ULA </string>
    <string name="q198">Registrador que indica o topo da pilha.</string>
    <string name="q198a">A)TOS (Top of Stack) </string>
    <string name="q198b">B)CISC(Complex Instruction Set Computer)</string>
    <string name="q198c">C)RISC (Reduced Instruction Set Computer) </string>
    <string name="q198d">D)MBR </string>
    <string name="q198e">E)ULA </string>
    <string name="q199">Ciclo escrever em memória. Escreve o resultado da operação em memória, se necessário.</string>
    <string name="q199a">A)WR (Write to register) </string>
    <string name="q199b">B)FO (Fetch operands)</string>
    <string name="q199c">C)FI (Fetch Instruction)</string>
    <string name="q199d">D)EI (Execute Instructions) </string>
    <string name="q199e">E)WM (Write to memory)</string>
    <string name="q200">Ciclo escrever em registrador. Escreve o resultado da operação em um dos registradores, se necessário.</string>
    <string name="q200a">A)WR (Write to register) </string>
    <string name="q200b">B)FO (Fetch operands)</string>
    <string name="q200c">C)FI (Fetch Instruction)</string>
    <string name="q200d">D)EI (Execute Instructions) </string>
    <string name="q200e">E)WM (Write to memory)</string>
    <string name="teste">&lt;-</string>
    <string name="teste3">%</string>

</resources>